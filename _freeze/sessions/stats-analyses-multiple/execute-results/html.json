{
  "hash": "3f5940f25d5471356420ea419098d4f8",
  "result": {
    "markdown": "# Efficiently running many analyses at once {#sec-stats-analyses-multiple}\n\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nBefore beginning, get them to recall what they remember of the previous\nsession, either with something like Mentimeter or verbally. Preferably\nsomething like Mentimeter because it allows everyone to participate, not\njust the ones who are more comfortable being vocal to the whole group.\n\nDepending on what they write, might need to briefly go over the previous\nsession.\n:::\n\nRarely do we run only one single statistical model to answer one single\nquestion, especially in our data-overflowing environments. An initial\ninstinct when faced with this task might be to copy-and-paste, then\nslightly modify the code each time. Or, if you have heard of loops or\nused them in other programming languages, you might think to create a\nloop. Thankfully R uses something more powerful and expressive than\neither of those approaches, and that is functional programming. Using\nfunctional programming concepts, we can use little code to express\ncomplex actions and run large numbers of statistical analyses. This\nsession will be about using functional programming in the context of\nstatistical analysis.\n\n## Learning objectives\n\nThe overall objective for this session is to:\n\n1.  Describe the basic framework underlying most statistical analyses\n    and use R to generate statistical results using this framework.\n\nMore specific objectives are to:\n\n1.  Recall principles of functional programming and apply them to\n    running statistical analyses by using the `{purrr}` package.\n2.  Continue applying the concepts and functions used from the previous\n    sessions.\n\nSpecific \"anti\"-objectives:\n\n-   Same as the \"anti\"-objectives of @sec-stats-analyses-basic.\n\n## Apply logistic regression to each metabolite with functional programming\n\n::: callout-note\n## Reading task: \\~10 minutes\n\nFunctional programming underlies many core features of running\nstatistical methods on data. Because it is such an important component\nof this session, you'll briefly review the concepts of functional\nprogramming by going to the [Function\nProgramming](https://r-cubed-intermediate.rostools.org/sessions/functionals#functional-programming)\nin the Intermediate R course (**only the reading task section**) as well\nas the\n[split-apply-combine](https://r-cubed-intermediate.rostools.org/sessions/functionals#split-apply-combine-technique-and-functionals)\n(this is a short section).\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nReinforce the concept of functional programming by briefly going over\nthe\n[figure](https://r-cubed-intermediate.rostools.org/sessions/functionals#fig-functionals)\nthat visualizes functionals like `map()`.\n:::\n\nThere are many ways that you can run a model on each metabolite based on\nthe `lipidomics_wide` dataset. However, these types of\n\"split-apply-combine\" tasks are (usually) best done using data in the\nlong form. So we'll start with the original `lipidomics` dataset. Create\na header and code chunk at the end of the `doc/learning.qmd` file:\n\n````         \n## Running multiple models\n\n```{{r}}\n\n```\n````\n\nThe first thing we want to do is convert the metabolite names into snake\ncase:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  column_values_to_snake_case(metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 504 × 6\n#>    code   gender   age class metabolite                value\n#>    <chr>  <chr>  <dbl> <chr> <chr>                     <dbl>\n#>  1 ERI109 M         25 CT    tms_interntal_standard   208.  \n#>  2 ERI109 M         25 CT    cholesterol               19.8 \n#>  3 ERI109 M         25 CT    lipid_ch_3_1              44.1 \n#>  4 ERI109 M         25 CT    lipid_ch_3_2             147.  \n#>  5 ERI109 M         25 CT    cholesterol               27.2 \n#>  6 ERI109 M         25 CT    lipid_ch_2               587.  \n#>  7 ERI109 M         25 CT    fa_ch_2_ch_2_coo          31.6 \n#>  8 ERI109 M         25 CT    pufa                      29.0 \n#>  9 ERI109 M         25 CT    phosphatidylethanolamine   6.78\n#> 10 ERI109 M         25 CT    phosphatidycholine        41.7 \n#> # ℹ 494 more rows\n```\n:::\n:::\n\n\nThe next step is to split the data up. We could use `group_by()`, but in\norder to make the most use of `{purrr}` functions like `map()`, we will\nuse `group_split()` to convert the data frame into a set of\nlists[^stats-analyses-multiple-1]. Let's first add `{purrr}` as a\ndependency:\n\n[^stats-analyses-multiple-1]: There is probably a more computationally\n    efficient way of coding this instead of making a list, but as the\n    saying goes [\"premature optimization is the root of all\n    evil\"](https://stackify.com/premature-optimization-evil/). For our\n    purposes, this is a very good approach, but for very large datasets\n    and hundreds of potential models to run, this method would need to\n    be optimized some more.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nuse_package(\"purrr\")\n```\n:::\n\n\nThen we run `group_split()` on the `metabolite` column, which will\noutput a lot of data frames as a list. The website only shows the first\nthree.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  column_values_to_snake_case(metabolite) %>%\n  group_split(metabolite)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> <list_of<\n#>   tbl_df<\n#>     code      : character\n#>     gender    : character\n#>     age       : double\n#>     class     : character\n#>     metabolite: character\n#>     value     : double\n#>   >\n#> >[3]>\n#> [[1]]\n#> # A tibble: 36 × 6\n#>    code   gender   age class metabolite      value\n#>    <chr>  <chr>  <dbl> <chr> <chr>           <dbl>\n#>  1 ERI109 M         25 CT    cd_cl_3_solvent  166.\n#>  2 ERI111 M         39 CT    cd_cl_3_solvent  171.\n#>  3 ERI163 W         58 CT    cd_cl_3_solvent  262.\n#>  4 ERI375 M         24 CT    cd_cl_3_solvent  172.\n#>  5 ERI376 M         26 CT    cd_cl_3_solvent  300.\n#>  6 ERI391 M         31 CT    cd_cl_3_solvent  241.\n#>  7 ERI392 M         24 CT    cd_cl_3_solvent  172.\n#>  8 ERI79  W         26 CT    cd_cl_3_solvent  148.\n#>  9 ERI81  M         52 CT    cd_cl_3_solvent  168.\n#> 10 ERI83  M         25 CT    cd_cl_3_solvent  253.\n#> # ℹ 26 more rows\n#> \n#> [[2]]\n#> # A tibble: 108 × 6\n#>    code   gender   age class metabolite  value\n#>    <chr>  <chr>  <dbl> <chr> <chr>       <dbl>\n#>  1 ERI109 M         25 CT    cholesterol 19.8 \n#>  2 ERI109 M         25 CT    cholesterol 27.2 \n#>  3 ERI109 M         25 CT    cholesterol  8.88\n#>  4 ERI111 M         39 CT    cholesterol 22.8 \n#>  5 ERI111 M         39 CT    cholesterol 30.2 \n#>  6 ERI111 M         39 CT    cholesterol  9.28\n#>  7 ERI163 W         58 CT    cholesterol 14.9 \n#>  8 ERI163 W         58 CT    cholesterol 24.0 \n#>  9 ERI163 W         58 CT    cholesterol  7.66\n#> 10 ERI375 M         24 CT    cholesterol 19.2 \n#> # ℹ 98 more rows\n#> \n#> [[3]]\n#> # A tibble: 36 × 6\n#>    code   gender   age class metabolite       value\n#>    <chr>  <chr>  <dbl> <chr> <chr>            <dbl>\n#>  1 ERI109 M         25 CT    fa_ch_2_ch_2_coo  31.6\n#>  2 ERI111 M         39 CT    fa_ch_2_ch_2_coo  28.9\n#>  3 ERI163 W         58 CT    fa_ch_2_ch_2_coo  36.6\n#>  4 ERI375 M         24 CT    fa_ch_2_ch_2_coo  39.4\n#>  5 ERI376 M         26 CT    fa_ch_2_ch_2_coo  52.1\n#>  6 ERI391 M         31 CT    fa_ch_2_ch_2_coo  42.8\n#>  7 ERI392 M         24 CT    fa_ch_2_ch_2_coo  39.9\n#>  8 ERI79  W         26 CT    fa_ch_2_ch_2_coo  32.7\n#>  9 ERI81  M         52 CT    fa_ch_2_ch_2_coo  28.4\n#> 10 ERI83  M         25 CT    fa_ch_2_ch_2_coo  26.5\n#> # ℹ 26 more rows\n```\n:::\n:::\n\n\nRemember that logistic regression models need each row to be a single\nperson, so we'll use the functional `map()` to apply our custom function\n`metabolites_to_wider()` on each of the split list items (only showing\nthe first three):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  column_values_to_snake_case(metabolite) %>%\n  group_split(metabolite) %>%\n  map(metabolites_to_wider)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [[1]]\n#> # A tibble: 36 × 5\n#>    code   gender   age class metabolite_cd_cl_3_solvent\n#>    <chr>  <chr>  <dbl> <chr>                      <dbl>\n#>  1 ERI109 M         25 CT                          166.\n#>  2 ERI111 M         39 CT                          171.\n#>  3 ERI163 W         58 CT                          262.\n#>  4 ERI375 M         24 CT                          172.\n#>  5 ERI376 M         26 CT                          300.\n#>  6 ERI391 M         31 CT                          241.\n#>  7 ERI392 M         24 CT                          172.\n#>  8 ERI79  W         26 CT                          148.\n#>  9 ERI81  M         52 CT                          168.\n#> 10 ERI83  M         25 CT                          253.\n#> # ℹ 26 more rows\n#> \n#> [[2]]\n#> # A tibble: 36 × 5\n#>    code   gender   age class metabolite_cholesterol\n#>    <chr>  <chr>  <dbl> <chr>                  <dbl>\n#>  1 ERI109 M         25 CT                     18.6 \n#>  2 ERI111 M         39 CT                     20.8 \n#>  3 ERI163 W         58 CT                     15.5 \n#>  4 ERI375 M         24 CT                     10.2 \n#>  5 ERI376 M         26 CT                     13.5 \n#>  6 ERI391 M         31 CT                      9.53\n#>  7 ERI392 M         24 CT                      9.87\n#>  8 ERI79  W         26 CT                     17.6 \n#>  9 ERI81  M         52 CT                     17.0 \n#> 10 ERI83  M         25 CT                     19.7 \n#> # ℹ 26 more rows\n#> \n#> [[3]]\n#> # A tibble: 36 × 5\n#>    code   gender   age class metabolite_fa_ch_2_ch_2_coo\n#>    <chr>  <chr>  <dbl> <chr>                       <dbl>\n#>  1 ERI109 M         25 CT                           31.6\n#>  2 ERI111 M         39 CT                           28.9\n#>  3 ERI163 W         58 CT                           36.6\n#>  4 ERI375 M         24 CT                           39.4\n#>  5 ERI376 M         26 CT                           52.1\n#>  6 ERI391 M         31 CT                           42.8\n#>  7 ERI392 M         24 CT                           39.9\n#>  8 ERI79  W         26 CT                           32.7\n#>  9 ERI81  M         52 CT                           28.4\n#> 10 ERI83  M         25 CT                           26.5\n#> # ℹ 26 more rows\n```\n:::\n:::\n\n\nAlright, we now a list of data frames where each data frame has only one\nof the metabolites. These bits of code represent the conceptual action\nof \"splitting the data into a list by metabolites\". Since we're\nfollowing a function-oriented workflow, let's create a function for\nthis. Convert it into a function, add the Roxygen documentation using\n{{< var keybind.roxygen >}} style using {{< var keybind.styler >}}, move\ninto the `R/functions.R` file, and then `source()` the file with\n{{< var keybind.source >}}.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#' Convert the long form dataset into a list of wide form data frames.\n#'\n#' @param data The lipidomics dataset.\n#'\n#' @return A list of data frames.\n#'\nsplit_by_metabolite <- function(data) {\n  data %>%\n    column_values_to_snake_case(metabolite) %>%\n    dplyr::group_split(metabolite) %>%\n    purrr::map(metabolites_to_wider)\n}\n```\n:::\n\n\nIn the `doc/learning.qmd`, use the new function in the code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  split_by_metabolite()\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [[1]]\n#> # A tibble: 36 × 5\n#>    code   gender   age class metabolite_cd_cl_3_solvent\n#>    <chr>  <chr>  <dbl> <chr>                      <dbl>\n#>  1 ERI109 M         25 CT                          166.\n#>  2 ERI111 M         39 CT                          171.\n#>  3 ERI163 W         58 CT                          262.\n#>  4 ERI375 M         24 CT                          172.\n#>  5 ERI376 M         26 CT                          300.\n#>  6 ERI391 M         31 CT                          241.\n#>  7 ERI392 M         24 CT                          172.\n#>  8 ERI79  W         26 CT                          148.\n#>  9 ERI81  M         52 CT                          168.\n#> 10 ERI83  M         25 CT                          253.\n#> # ℹ 26 more rows\n#> \n#> [[2]]\n#> # A tibble: 36 × 5\n#>    code   gender   age class metabolite_cholesterol\n#>    <chr>  <chr>  <dbl> <chr>                  <dbl>\n#>  1 ERI109 M         25 CT                     18.6 \n#>  2 ERI111 M         39 CT                     20.8 \n#>  3 ERI163 W         58 CT                     15.5 \n#>  4 ERI375 M         24 CT                     10.2 \n#>  5 ERI376 M         26 CT                     13.5 \n#>  6 ERI391 M         31 CT                      9.53\n#>  7 ERI392 M         24 CT                      9.87\n#>  8 ERI79  W         26 CT                     17.6 \n#>  9 ERI81  M         52 CT                     17.0 \n#> 10 ERI83  M         25 CT                     19.7 \n#> # ℹ 26 more rows\n#> \n#> [[3]]\n#> # A tibble: 36 × 5\n#>    code   gender   age class metabolite_fa_ch_2_ch_2_coo\n#>    <chr>  <chr>  <dbl> <chr>                       <dbl>\n#>  1 ERI109 M         25 CT                           31.6\n#>  2 ERI111 M         39 CT                           28.9\n#>  3 ERI163 W         58 CT                           36.6\n#>  4 ERI375 M         24 CT                           39.4\n#>  5 ERI376 M         26 CT                           52.1\n#>  6 ERI391 M         31 CT                           42.8\n#>  7 ERI392 M         24 CT                           39.9\n#>  8 ERI79  W         26 CT                           32.7\n#>  9 ERI81  M         52 CT                           28.4\n#> 10 ERI83  M         25 CT                           26.5\n#> # ℹ 26 more rows\n```\n:::\n:::\n\n\nLike we did with the `metabolite_to_wider()`, we need to pipe the output\ninto another `map()` function that has a custom function running the\nmodels. We don't have this function yet, so we need to create it. Let's\nconvert the modeling code we used in the exercise above into a function,\nreplacing `lipidomics` with `data` and using\n`starts_with(\"metabolite_\")` within the `create_recipe_spec()`. Add the\nRoxygen documentation using {{< var keybind.roxygen >}}, use\n{{< var keybind.styler >}} to style, move into the `R/functions.R` file,\nand then `source()` the file with {{< var keybind.source >}}.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#' Generate the results of a model\n#'\n#' @param data The lipidomics dataset.\n#'\n#' @return A data frame.\n#'\ngenerate_model_results <- function(data) {\n  create_model_workflow(\n    parsnip::logistic_reg() %>%\n      parsnip::set_engine(\"glm\"),\n    data %>%\n      create_recipe_spec(tidyselect::starts_with(\"metabolite_\"))\n  ) %>%\n    parsnip::fit(data) %>%\n    tidy_model_output()\n}\n```\n:::\n\n\nThen we add it to the end of the pipe, but using `map()` and\n`list_rbind()` to convert to a data frame:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  split_by_metabolite() %>%\n  map(generate_model_results) %>% \n  list_rbind()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 48 × 5\n#>    term                       estimate std.error statistic p.value\n#>    <chr>                         <dbl>     <dbl>     <dbl>   <dbl>\n#>  1 (Intercept)                  0.855     1.57     -0.0995 0.921  \n#>  2 genderW                      3.18      0.943     1.23   0.220  \n#>  3 age                          0.981     0.0478   -0.412  0.680  \n#>  4 metabolite_cd_cl_3_solvent   0.0870    0.865    -2.82   0.00475\n#>  5 (Intercept)                  1.11      1.29      0.0817 0.935  \n#>  6 genderW                      0.493     0.779    -0.907  0.365  \n#>  7 age                          1.01      0.0377    0.183  0.855  \n#>  8 metabolite_cholesterol       2.97      0.458     2.38   0.0175 \n#>  9 (Intercept)                  0.944     1.19     -0.0481 0.962  \n#> 10 genderW                      1.38      0.746     0.428  0.668  \n#> # ℹ 38 more rows\n```\n:::\n:::\n\n\nSince we are only interested in the model results for the metabolites,\nlet's keep only the `term` rows that are metabolites using `filter()`\nand `str_detect()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_estimates <- lipidomics %>%\n  split_by_metabolite() %>%\n  map(generate_model_results) %>%\n  list_rbind() %>% \n  filter(str_detect(term, \"metabolite_\"))\nmodel_estimates\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 12 × 5\n#>    term                         estimate std.error statistic p.value\n#>    <chr>                           <dbl>     <dbl>     <dbl>   <dbl>\n#>  1 metabolite_cd_cl_3_solvent  8.70e-  2   8.65e-1 -2.82     0.00475\n#>  2 metabolite_cholesterol      2.97e+  0   4.58e-1  2.38     0.0175 \n#>  3 metabolite_fa_ch_2_ch_2_coo 1.52e+  0   3.87e-1  1.09     0.276  \n#>  4 metabolite_lipid_ch_2       2.59e-  3   3.14e+0 -1.90     0.0578 \n#>  5 metabolite_lipid_ch_3_1     4.45e+  1   1.41e+0  2.70     0.00697\n#>  6 metabolite_lipid_ch_3_2     8.85e-  1   3.61e-1 -0.339    0.734  \n#>  7 metabolite_mufa_pufa        4.56e-  1   4.49e-1 -1.75     0.0798 \n#>  8 metabolite_phosphatidychol… 1.28e-120   1.17e+5 -0.00237  0.998  \n#>  9 metabolite_phosphatidyleth… 2.69e+  1   1.32e+0  2.49     0.0129 \n#> 10 metabolite_phospholipids    2.39e- 19   6.90e+4 -0.000622 1.00   \n#> 11 metabolite_pufa             3.27e+  0   5.60e-1  2.11     0.0345 \n#> 12 metabolite_tms_interntal_s… 5.62e-  2   9.90e-1 -2.91     0.00363\n```\n:::\n:::\n\n\nWow! We're basically at our first `{targets}` output! Before continuing,\nthere is one aesthetic thing we can add: The original variable names,\nrather than the snake case version. Since the original variable still\nexists in our `lipidomics` dataset, we can join it to the\n`model_estimates` object with `right_join()`, along with a few other\nminor changes. First, we'll `select()` only the `metabolite` and then\ncreate a duplicate column of `metabolite` called `term` (to match the\n`model_estimates`) using `mutate()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  select(metabolite) %>%\n  mutate(term = metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 504 × 2\n#>    metabolite               term                    \n#>    <chr>                    <chr>                   \n#>  1 TMS (interntal standard) TMS (interntal standard)\n#>  2 Cholesterol              Cholesterol             \n#>  3 Lipid CH3- 1             Lipid CH3- 1            \n#>  4 Lipid CH3- 2             Lipid CH3- 2            \n#>  5 Cholesterol              Cholesterol             \n#>  6 Lipid -CH2-              Lipid -CH2-             \n#>  7 FA -CH2CH2COO-           FA -CH2CH2COO-          \n#>  8 PUFA                     PUFA                    \n#>  9 Phosphatidylethanolamine Phosphatidylethanolamine\n#> 10 Phosphatidycholine       Phosphatidycholine      \n#> # ℹ 494 more rows\n```\n:::\n:::\n\n\nRight after that we will use our custom `column_values_to_snake_case()`\nfunction on the `term` column.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  select(metabolite) %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snake_case(term)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 504 × 2\n#>    metabolite               term                    \n#>    <chr>                    <chr>                   \n#>  1 TMS (interntal standard) tms_interntal_standard  \n#>  2 Cholesterol              cholesterol             \n#>  3 Lipid CH3- 1             lipid_ch_3_1            \n#>  4 Lipid CH3- 2             lipid_ch_3_2            \n#>  5 Cholesterol              cholesterol             \n#>  6 Lipid -CH2-              lipid_ch_2              \n#>  7 FA -CH2CH2COO-           fa_ch_2_ch_2_coo        \n#>  8 PUFA                     pufa                    \n#>  9 Phosphatidylethanolamine phosphatidylethanolamine\n#> 10 Phosphatidycholine       phosphatidycholine      \n#> # ℹ 494 more rows\n```\n:::\n:::\n\n\nWe can see that we are missing the `metabolite_` text before each snake\ncase'd name, so we can add that with `mutate()` and `str_c()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  select(metabolite) %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snake_case(term) %>%\n  mutate(term = str_c(\"metabolite_\", term))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 504 × 2\n#>    metabolite               term                               \n#>    <chr>                    <chr>                              \n#>  1 TMS (interntal standard) metabolite_tms_interntal_standard  \n#>  2 Cholesterol              metabolite_cholesterol             \n#>  3 Lipid CH3- 1             metabolite_lipid_ch_3_1            \n#>  4 Lipid CH3- 2             metabolite_lipid_ch_3_2            \n#>  5 Cholesterol              metabolite_cholesterol             \n#>  6 Lipid -CH2-              metabolite_lipid_ch_2              \n#>  7 FA -CH2CH2COO-           metabolite_fa_ch_2_ch_2_coo        \n#>  8 PUFA                     metabolite_pufa                    \n#>  9 Phosphatidylethanolamine metabolite_phosphatidylethanolamine\n#> 10 Phosphatidycholine       metabolite_phosphatidycholine      \n#> # ℹ 494 more rows\n```\n:::\n:::\n\n\nThere are 504 rows, but we only need the unique values of `term` and\n`metabolite`, which we can get with `distinct()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snake_case(term) %>%\n  mutate(term = str_c(\"metabolite_\", term)) %>%\n  distinct(term, metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 12 × 2\n#>    term                                metabolite              \n#>    <chr>                               <chr>                   \n#>  1 metabolite_tms_interntal_standard   TMS (interntal standard)\n#>  2 metabolite_cholesterol              Cholesterol             \n#>  3 metabolite_lipid_ch_3_1             Lipid CH3- 1            \n#>  4 metabolite_lipid_ch_3_2             Lipid CH3- 2            \n#>  5 metabolite_lipid_ch_2               Lipid -CH2-             \n#>  6 metabolite_fa_ch_2_ch_2_coo         FA -CH2CH2COO-          \n#>  7 metabolite_pufa                     PUFA                    \n#>  8 metabolite_phosphatidylethanolamine Phosphatidylethanolamine\n#>  9 metabolite_phosphatidycholine       Phosphatidycholine      \n#> 10 metabolite_phospholipids            Phospholipids           \n#> 11 metabolite_mufa_pufa                MUFA+PUFA               \n#> 12 metabolite_cd_cl_3_solvent          CDCl3 (solvent)\n```\n:::\n:::\n\n\nThe last step is to `right_join()` with the `model_estimates`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlipidomics %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snake_case(term) %>%\n  mutate(term = str_c(\"metabolite_\", term)) %>%\n  distinct(term, metabolite) %>%\n  right_join(model_estimates, by = \"term\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 12 × 6\n#>    term             metabolite  estimate std.error statistic p.value\n#>    <chr>            <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n#>  1 metabolite_tms_… TMS (inte… 5.62e-  2   9.90e-1 -2.91     0.00363\n#>  2 metabolite_chol… Cholester… 2.97e+  0   4.58e-1  2.38     0.0175 \n#>  3 metabolite_lipi… Lipid CH3… 4.45e+  1   1.41e+0  2.70     0.00697\n#>  4 metabolite_lipi… Lipid CH3… 8.85e-  1   3.61e-1 -0.339    0.734  \n#>  5 metabolite_lipi… Lipid -CH… 2.59e-  3   3.14e+0 -1.90     0.0578 \n#>  6 metabolite_fa_c… FA -CH2CH… 1.52e+  0   3.87e-1  1.09     0.276  \n#>  7 metabolite_pufa  PUFA       3.27e+  0   5.60e-1  2.11     0.0345 \n#>  8 metabolite_phos… Phosphati… 2.69e+  1   1.32e+0  2.49     0.0129 \n#>  9 metabolite_phos… Phosphati… 1.28e-120   1.17e+5 -0.00237  0.998  \n#> 10 metabolite_phos… Phospholi… 2.39e- 19   6.90e+4 -0.000622 1.00   \n#> 11 metabolite_mufa… MUFA+PUFA  4.56e-  1   4.49e-1 -1.75     0.0798 \n#> 12 metabolite_cd_c… CDCl3 (so… 8.70e-  2   8.65e-1 -2.82     0.00475\n```\n:::\n:::\n\n\nAwesome :smile: Now can you guess what we are going to do next? That's\nright, making a function of both the model creation code and this code\nto add the original variable names. Then we can add our first\n`{targets}` output!\n\n## Exercise: Creating functions for model results and adding as a target in the pipeline\n\n> Time: \\~25 minutes.\n\nConvert the code that calculates the model estimates as well as the code\nthat adds the original metabolite names into functions. Start with the\ncode for the metabolite names, using the scaffold below as a starting\npoint.\n\n1.  Name the new function `add_original_metabolite_names`.\n2.  Within the `function()`, add two arguments, where the first is\n    called `model_results` and the second is called `data`.\n3.  Paste the code we created into the function, replacing `lipidomics`\n    with `data` and `model_estimates` with `model_results`.\n4.  Add `dplyr::` and `stringr::` before their respective functions.\n5.  Add the Roxygen documentation using {{< var keybind.roxygen >}}.\n6.  Use {{< var keybind.styler >}} to style the file to fix up the code.\n7.  Cut and paste the function over into the `R/functions.R` file.\n8.  Commit the changes you've made so far with {{< var keybind.git >}}.\n\n``` r\n___ <- function(___, ___) {\n  ___ %>%\n}\n```\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Add the original metabolite names (not as snakecase) to the model results.\n#'\n#' @param model_results The data frame with the model results.\n#' @param data The original lipidomics dataset.\n#'\n#' @return A data frame.\n#'\nadd_original_metabolite_names <- function(model_results, data) {\n  data %>%\n    dplyr::mutate(term = metabolite) %>%\n    column_values_to_snake_case(term) %>%\n    dplyr::mutate(term = stringr::str_c(\"metabolite_\", term)) %>%\n    dplyr::distinct(term, metabolite) %>%\n    dplyr::right_join(model_results, by = \"term\")\n}\n```\n:::\n\n\nDo the same thing with the code that creates the model results, using\nthe scaffold below as a starting point.\n\n``` r\ncalculate_estimates <- function(data) {\n  ___ %>%\n    # All the other code to create the results\n    ___ %>% \n    add_original_metabolite_names(data) \n}\n```\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Calculate the estimates for the model for each metabolite.\n#'\n#' @param data The lipidomics dataset.\n#'\n#' @return A data frame.\n#'\ncalculate_estimates <- function(data) {\n  data %>%\n    column_values_to_snake_case(metabolite) %>%\n    dplyr::group_split(metabolite) %>%\n    purrr::map(metabolites_to_wider) %>%\n    purrr::map(generate_model_results) %>%\n    purrr::list_rbind() %>% \n    dplyr::filter(stringr::str_detect(term, \"metabolite_\")) %>%\n    add_original_metabolite_names(data)\n}\n```\n:::\n\n\nLastly, add the model results output to end of the `_targets.R` file,\nusing the below scaffold as a guide.\n\n1.  Use `df_model_estimates` for the `name`.\n2.  Use the `calculate_estimates()` function in `command`, with\n    `lipidomics` as the argument.\n3.  Use {{< var keybind.styler >}} to style and than run\n    `targets::tar_visnetwork()` using {{< var keybind.targets_vis >}} to\n    see if the new target gets detected. If it does, than run\n    `targets::tar_make()` with {{< var keybind.targets_make >}}.\n4.  Commit the changes to the Git history with {{< var keybind.git >}}.\n\n``` r\nlist(\n  ...,\n  tar_target(\n    name = ___,\n    command = ___(___)\n  )\n)\n```\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## Visualizing the model estimates\n\nWe've got one target done for the modeling stage, three more to go!\nThere are multiple ways of visualizing the results from models. A common\napproach is to use a \"dot-and-whisker\" plot like you might see in a\nmeta-analysis. Often the \"whisker\" part is the measure of uncertainty\nlike the confidence interval, and the \"dot\" is the estimate. For the\nconfidence interval, we haven't calculated them at this point because\nthe typical approach doesn't exactly work for our data (tested before\nthe course). For this plot though, we will use the standard error of the\nestimate.\n\nInside the `doc/learning.qmd`, let's create a new header and code chunk\ninside the `## Results` section. We'll want to use\n`tar_read(df_model_estimates)` so that `{targets}` is aware that the R\nMarkdown file is dependent on this target.\n\n````         \n### Figure of model estimates\n\n```{{r}}\nmodel_estimates <- tar_read(df_model_estimates)\n```\n````\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\nThen we'll start using `{ggplot2}` to visualize the results. For\ndot-whisker plots, the \"geom\" we would use is called\n`geom_pointrange()`. It requires four values:\n\n-   `x`: This will be the \"dot\", representing the `estimate` column.\n-   `y`: This is the categorical variable that the \"dot\" is associated\n    with, in this case, it is the `metabolite` column.\n-   `xmin`: This is the lower end of the \"whisker\". Since the\n    `std.error` is a value representing uncertainty of the estimate on\n    either side of it (`+` or `-`), we will need to subtract `std.error`\n    from the `estimate`.\n-   `xmax`: This is the upper end of the \"whisker\". Like `xmin` above,\n    but adding `std.error` instead.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_estimates <- model_estimates %>% \n  ggplot(aes(\n    x = estimate, \n    y = metabolite,\n    xmin = estimate - std.error,\n    xmax = estimate + std.error\n  )) +\n  geom_pointrange()\nplot_estimates\n```\n\n::: {.cell-output-display}\n![](stats-analyses-multiple_files/figure-html/plot-estimates-pointrange-only-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nWoah, there is definitely something wrong here. The values of the\nestimate should realistically be somewhere between 0 (can't have a\nnegative odds) and 2 (in biology and health research, odds ratios are\nrarely above 2), definitely unlikely to be more than 5. We will\neventually need to troubleshoot this issue, but for now, let's restrict\nthe x axis to be between 0 and 5.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_estimates +\n  coord_fixed(xlim = c(0, 5))\n```\n\n::: {.cell-output-display}\n![](stats-analyses-multiple_files/figure-html/plot-estimates-coord-fixed-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nThere are so many things we could start investigating based on these\nresults in order to fix them up. But for now, this will do.\n\n## Exercise: Add plot function as a target in the pipeline\n\n> Time: \\~15 minutes.\n\nHopefully you've gotten comfortable with the function-oriented workflow,\nbecause we'll need to convert this plot code into a function and add it\nas a target in the pipeline. Use the scaffold below as a guide.\n\n1.  Replace `model_estimates` with `results`.\n2.  Move the function into the `R/functions.R` file, add the Roxygen\n    documentation using {{< var keybind.roxygen >}}, and use\n    {{< var keybind.styler >}} to style.\n\n``` r\nplot_estimates <- function(results) {\n  ___ %>% \n    # Plot code here:\n    ___\n}\n```\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Plot the estimates and standard errors of the model results.\n#'\n#' @param results The model estimate results.\n#'\n#' @return A ggplot2 figure.\n#'\nplot_estimates <- function(results) {\n  results %>%\n    ggplot2::ggplot(ggplot2::aes(\n      x = estimate, y = metabolite,\n      xmin = estimate - std.error,\n      xmax = estimate + std.error\n    )) +\n    ggplot2::geom_pointrange() +\n    ggplot2::coord_fixed(xlim = c(0, 5))\n}\n```\n:::\n\n\nThen, after doing that, add the new function as a target in the\npipeline, name the new `name` as `fig_model_estimates`. Inside the\n`plot_estimates()` function, use the the model estimate target we\ncreated previously (`df_model_estimates`).\n\n``` r\nlist(\n  ...,\n  tar_target(\n    name = ___,\n    command = plot_estimates(___)\n  )\n)\n```\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\nlist(\n  # ...,\n  tar_target(\n    name = fig_model_estimates,\n    command = plot_estimates(df_model_estimates)\n  )\n)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## Combine all the output into the Quarto file\n\nNow its' time to add the model results and plots to the\n`doc/learning.qmd` file. Open it up and create another code chunk at the\nbottom of the file. Like we did with the other outputs (like the\nfigures), we'll use `tar_read()` to reference the image path.\n\n```{{r}}\ntar_read(fig_model_estimates)\n```\n\nRun `targets::tar_visnetwork()` using {{< var keybind.targets_vis >}},\nthen `targets::tar_make()` with {{< var keybind.targets_make >}}. We now\nhave the report rendered to an HTML file! If you open it up in a\nbrowser, we can see the figures added to it. In the next session we will\nget more into making the document output nicer looking and creating it\nas a website. Before ending, commit the changes to the Git history with\n{{< var keybind.git >}}.\n\n<!-- TODO: Check that the output is rendered to html. Don't forget the TODO -->\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## Summary\n\n-   Use functional programming with `map()`, as part of the\n    function-oriented workflow, to run multiple models efficiently and\n    with minimal code.\n-   Consistently create small functions that do a specific conceptual\n    action and chain them together into larger conceptual actions, which\n    can then more easily be incorporated into a `{targets}` pipeline.\n    Small, multiple functions combined together are easier to manage\n    than fewer, bigger ones.\n-   Use dot-whisker plots like `geom_pointrange()` to visualize the\n    estimates and their standard error.\n",
    "supporting": [
      "stats-analyses-multiple_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}