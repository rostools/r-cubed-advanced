{
  "hash": "5c02f08b4f0612233c6744ba13e38432",
  "result": {
    "engine": "knitr",
    "markdown": "# Smoother project-based collaboration {#sec-smoother-collaboration}\n\n\n\n\n\n\n\n\n\nMany of you probably work largely and most consistently on your own, but\nas your move through your career (in academia or industry), you will\nneed to and maybe also want to *directly\ncollaborate*[^smoother-collaboration-1] a lot more with others.\nDifferent types of collaboration (e.g. meetings, brainstorming,\nreal-time co-writing) form the basis for almost all research-based work\nand probably most non-research-based work.\n\n[^smoother-collaboration-1]: Collaborate here meaning directly\n    contributing to a shared project, rather than discussed or planning\n    based collaborations (and definitely not emailing-files-around\n    collaboration).\n\nMore direct collaboration on a project quickly becomes unmanageable when\nusing traditional academic \"workflows\" (emailing around). That's when\nyou need to start using tools designed for collaboration, like Git. But\nGit is just the starting point. There are many many other things to\nconsider for workflows and processes to effectively collaborate with\nothers. This session is about making use of more automated ways of\nstructuring data analysis projects to ease collaboration.\n\n## Learning objectives\n\nThe overall objective for this session is to:\n\n1.  Identify potential actions to streamline collaboration on a data\n    analysis project and create projects that apply many of these\n    actions using R.\n\nMore specific objectives are to:\n\n1.  Explain what a \"project-oriented\" workflow is, what a project-level\n    R dependency management is, and why these concepts are important to\n    consider in collaborative and reproducible analyses.\n2.  Describe the difference between \"workflow dependencies\" and \"build\n    dependencies\".\n3.  Apply functions in the `{usethis}` R package to implement these\n    dependency management concepts.\n4.  Explain the role that following a style guide has on building a\n    common approach to reading (and writing) R code, and thus improve\n    project-level collaboration.\n5.  Use `{styler}` and RStudio's canonical markdown mode to\n    programmatically check and apply style guides to your project files.\n\n## Exercise: How do you *exactly* collaborate or contribute? To your own or others' projects.\n\n> Time: \\~10 minutes.\n\nWhen you work on a project (for your thesis or a manuscript), how\n**exactly** do you and your collaborators contribute to the project? Is\nit mostly verbal contributions? Do you use a shared folder that the\nfiles are on? How do you keep track of who's changed what? Do you mostly\nwork on your own and contributions are largely verbal or written\nfeedback (like in a meeting or through an email)? If you work directly\non a project, how do you coordinate things? Does one collaborator work\non one section or analysis, so your files are separate? Do you ever have\nto go in and contribute your own code to theirs (and vice versa)?\n\n1.  Take about 1 minute to think on these questions.\n2.  For 6 minutes, discuss these questions with your neighbour, and talk\n    about your own experiences.\n3.  For the remaining time, we will share briefly with everyone.\n\n## Project-level R dependency management\n\n> Note: This first session is more conceptual and is heavier on the\n> reading and explanation, but is important for the next sessions.\n\n::: callout-note\n## Reading task: \\~8 minutes\n\nOne of the first things to consider when working collaboratively on a\ndata analysis project (and probably other types of projects too) is what\nsoftware to use for your project. This starts out at the highest level:\nAre you using R or some other software for the analysis? Since this is\nan R course, we're assuming the software will be R! ðŸ˜œ\n\nThe next consideration is which packages your project depends on to\nproduce the results. When working collaboratively with others, and\nyourself several months in the future, you need some way of knowing how\nto easily and quickly install or update these package dependencies.\n\nPart of this approach requires that you follow a [\"project-oriented\"\nworkflow](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)\nwhen working on, well, your project. In order to know how to track your\nproject's package dependencies, you need to first know, what is a\n\"project\" and how do we work around it? Since the introduction course's\nfirst session on the [Management of R\nProjects](https://r-cubed-intro.rostools.org/sessions/project-management.html),\nwe've consistently taught and used this workflow-style. In fact, it is\nembedded into the use of the R Projects via the `.Rproj` files and in\nthe use of the `{here}` package. So we already are following this\napproach from the start, which will make it easier to track package\ndependencies of our project.\n\n![Cartoon of combining R Projects with the `{here}` package, compared to\nthe common approach of using `setwd()`. [Artwork by\n\\@allison_horst.](https://allisonhorst.com/allison-horst)](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/e684ee45-98fc-469e-997c-e2d68b0096cd_rw_1920.png?h=d754f634e6fc1e292430124fbe44dad7)\n\nLet's start with the `AdvancedR3` project that uses the `lipidomics`. We\nhave code in the `data-raw/nmr-omics.R` file that uses some packages.\nLet's assume that your project will be more complex than this and that\nyou will eventually need some collaborators to contribute who are\nexperts in for instance metabolomics data processing and in statistical\nanalysis of high-dimensional data. You know you will end up needing to\nuse other packages. You also know that you all need some way of tracking\nwhich packages are used so that when others join and contribute to the\nproject, they can as seamlessly as possible install or update the\npackages your data analysis project needs. There are a few ways of\n\"tracking\" package dependencies.\n\nThe simplest, but most primitive way is to always make sure to use\n`library()` at the top of each R script for each package that the R\nscript uses.\n\n-   Advantage:\n\n    -   This is the easiest to conceptually understand and to use.\n\n-   Disadvantages:\n\n    -   It doesn't track project-level dependencies very well, since\n        multiple scripts probably use similar packages across them.\n        Which means you can't easily and quickly install or update all\n        the packages your project uses, since you will probably have to\n        go through each R script manually and install each package\n        manually. You might have seen some scripts with code that looks\n        like this at the top:\n\n        ``` r\n        if (!require(\"packagename\")) {\n          install.packages(\"packagename\")\n        }\n        ```\n\n        This code checks if a package exists, if not, it installs it.\n        But! This is not an optimal method to track packages because\n        `require()` won't load the package if it doesn't find it. Which\n        means you would have to re-run the script probably a few times.\n        Plus, sometimes you may need to restart the R session after\n        installing a package in order for R to detect it properly.\n\n    -   It doesn't track the *versions* of the packages your project\n        depends on, so if a package gets updated and it breaks\n        something, you might not be able to figure out how to quickly\n        fix that issue, especially for those deadline crunches.\n:::\n\n## Formal dependency management\n\n<!-- TODO: As a reading activity or explained by the instructor? -->\n\n:::: callout-note\n## Reading task: \\~3 minutes\n\nThe most common form, at least based on R packages and projects found on\nGitHub, of more formal dependency management makes use of the\n`DESCRIPTION` file and `usethis::use_package()` to track if a package is\nused for a project or not. We covered this style of dependency in the\n[intermediate\ncourse](https://r-cubed-intermediate.rostools.org/dry-functions.html#continuing-the-workflow).\nWe will also use this approach during this course, but expand a lot more\non it. We use and recommend it because a lot of tools and workflows\nexist that make use of it, so it is well integrated in working on R\nprojects.\n\n-   Advantages:\n\n    -   Relatively easy to conceptually understand, since you can\n        directly view the packages your project needs by opening the\n        `DESCRIPTION` file and looking at the contents.\n\n    -   Because it is widely used, there are many processes already\n        built around making use of tracking dependencies this way. For\n        instance, you need to track package dependencies when creating R\n        packages.\n\n    -   Installing packages is as easy as opening the project and\n        running `pak::pak()` in the Console, which will install all the\n        packages listed in the `DESCRIPTION` file.\n\n    -   Adding packages that you need is as easy as writing\n        `usethis::use_package(\"packagename\")` in the Console.\n\n-   Disadvantages:\n\n    -   Like the previous method, it doesn't easily keep track of the\n        versions of the packages you are using.\n\n    -   Your project might still rely on a package that is installed on\n        *your* computer and that influences your project, but that might\n        not be obvious as a dependency or that you forgot to include.\n\n::: callout-note\nThere is an even more formal and structured way of tracking dependencies\nusing the [renv](https://rstudio.github.io/renv/index.html) package,\nthat we originally covered in previous versions of this course but we\nwon't be covering anymore. It is a great package to use, especially if\nyou are working on a project with several others or that require\ntracking not just packages but their specific versions. We don't teach\nit anymore because it is quite complex, difficult to understand, and for\nthe majority of projects is never needed.\n:::\n\nAs we work on the project and realize we need to use a specific package,\nwe will continue using `usethis::use_package()` to install it and add it\nto the `DESCRIPTION` file. That also allows us to easily install all the\npackages our project depends on by using `pak::pak()`.\n::::\n\nBefore continuing to the exercise, we need to make sure to add and\ncomment all the files from the project into the Git history. Open the\nGit interface by either typing with {{< var keybind.git >}} or by going\nto the Git pane and clicking the \"Commit\" button.\n\n## Exercise: Add packages from the data processing script\n\n> Time: \\~10 minutes.\n\nSince the `DESCRIPTION` file will be used later on for the more formal\ndependency management, let's get it updated with the packages we are\nusing in the `data-raw/nmr-omics.R` script. Open that file and complete\nthese tasks:\n\n1.  **Manually** look for package dependencies in the R script that are\n    declared with `library()` and `::`. It can help to use the \"Find in\n    files\" feature in RStudio to look for all places that have either\n    `::` or `library`. Use either `Edit -> Find in Files ...`, or with\n    {{< var keybind.find >}} to open up the search popup.\n2.  Use `?usethis::use_package` to review how to use this function.\n3.  In the Console, run `usethis::use_package()` for each package you\n    find in `data-raw/nmr-omics.R` (from 1. above).\n4.  Since we are also using the `{usethis}` package to manage these\n    things, run `usethis::use_package(\"usethis\")` to also add it as a\n    package dependency.\n5.  Once done, open the Git interface with {{< var keybind.git >}} (or\n    going to the Git Pane and clicking the \"Commit\" button). What has\n    been changed? Commit those changes to the Git history .\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are really struggling or are out of time for the exercise.\"}\nusethis::use_package(\"stringr\")\nusethis::use_package(\"readxl\")\nusethis::use_package(\"dplyr\")\nusethis::use_package(\"tidyr\")\nusethis::use_package(\"snakecase\")\nusethis::use_package(\"here\")\nusethis::use_package(\"fs\")\nusethis::use_package(\"readr\")\nusethis::use_package(\"usethis\")\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nMake sure that everyone has added the right packages, since it can be\neasy to miss some of the packages referenced using `::`.\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\n## Two types of dependencies\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nVerbally explain the content of the next few paragraphs (don't need to\nshow the website on the projector).\n:::\n\nWhen you work on a research project that involves data analysis, you\nlikely use packages in two different ways:\n\n1.  Packages that directly contribute to data wrangling, analysis,\n    plotting, and making the manuscript. These types of packages are\n    generally called \"build\" or \"deploy\" dependencies. A package like\n    `{dplyr}` or `{tidyr}` would be build dependencies, since you use\n    them for processing data.\n2.  Packages that assist you in doing your work but aren't directly used\n    for data analysis. These types of packages would be called\n    \"workflow\" or \"development\" dependencies. `{usethis}` would be\n    considered a workflow dependency.\n\nA good way to determine if a package is a *build dependency* for your\nproject is by seeing if you write and use functions from the package\nwithin an R script that does something to the data or analysis. If you\n*only* ever use functions from the package in the Console, than it is\nlikely a *workflow dependency*.\n\nThe way you add these packages is different depending on the type it is.\nFor build dependencies, we use the function we've already used before:\n`usethis::use_package(\"packagename\")`. For workflow dependencies, it's\nthe same function, but with a small difference. BUT! Before we cover it,\nlet's add a setting to our `.Rprofile` to make our life a bit easier. We\nwill be using `{usethis}` functions many times throughout the course, so\na simple quality-of-life fix is to make it so we don't always have to do\n`usethis::`. Thankfully, there is a function that can help. Run the\n`usethis::use_usethis()` function to open your own (user) `.Rprofile`\nand add some code into it.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nusethis::use_usethis()\n```\n:::\n\n\n\n\nThen copy and paste this code into the `.Rprofile`, \\*\\*at the bottom of\nyour `.Rprofile`.\n\n``` r\nif (interactive()) {\n  suppressMessages(require(usethis))\n}\n```\n\nLet's restart R with {{< var keybind.restart-r >}} before using\n`use_package()` to add `{usethis}` as a workflow dependency.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nuse_package(\"usethis\", \"suggests\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\nOpen the Git interface and see that under `Suggests:` in the\n`DESCRIPTION` file is `usethis`. Let's commit these changes, with\n{{< var keybind.git >}}.\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nFor the information block below, mention it to the learners but you\ndon't need to go over it. Especially mention the second part of the tip.\n:::\n\n::: {.callout-tip appearance=\"default\"}\nWhen you come back to a project after a few months or if you start\ncollaborating on a project, you can run `pak::pak()` and it should\ninstall all types of dependencies, both workflow and build.\n:::\n\n## Exercise: Connect your project to GitHub\n\n> Time: \\~25 minutes.\n\nSince we will eventually connect our project Git repository to GitHub to\npractice the workflow, we'll connect our project to GitHub right now.\n\nLet's complete these tasks to connect to GitHub.\n\n1.  First, commit the latest changes to the Git history with\n    {{< var keybind.git >}}.\n\n2.  If you haven't yet, please create a\n    [GitHub](https://github.com/join) account.\n\n3.  Add the `{gitcreds}` package as a workflow dependency. You'll need\n    it for the next item\n\n    ``` r\n    use_package(\"gitcreds\", \"suggests\")\n    ```\n\n4.  Read through and complete the tasks in the [*linking your project to\n    GitHub* of the *Connect to GitHub*\n    Guide](https://guides.rostools.org/connect-github#linking-your-project-to-github).\n\n5.  Check your GitHub to make sure the project repository has been\n    uploaded to it.\n\n## Automatically adhere to a style guide\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nWe've covered how to adhere to a style guide in both the introductory as\nwell as the intermediate course, because it is such a useful and\npowerful tool to easily write more readable code. We'll expand on it in\nthis course because it fits precisely with the theme of collaboration.\nThat's because, when you're working on your own and not needing to worry\nabout anyone seeing your code, there's a natural temptation to write\nyour code like you might write notes to yourself... scribbled and\nscrawled down quickly. But when working with others, how it looks can\ngreatly impact how quickly and easily others are able to read and\ninterpret your code. Multiply all the collaborators on a project with\nthis natural temptation for quick (and sloppy) coding, you can imagine\nhow easy it is for code to massively \"drift\" towards being poorly\nformatted, especially when deadlines are close.\n\nThat's when \"linters\" or \"stylers\" (types of \"static code analysis\"\ntools) become very useful. They will scan your code for common mistakes\nor syntax problems and either list them out for you to fix or fix them\nfor you automatically. Linters are great when you are collaborating on a\nproject with collaborators who are not as experienced in writing code or\nwho only occasionally contribute so don't know the workflow culture of\nyour project. In this way, you might want to have automatic\nlinting/styling checks that are independent of you having to run them\nyourself. This is where the `{styler}` package comes in!\n\nSince we will use it for the project as a workflow dependency, let's add\nit to the `DESCRIPTION` file.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nuse_package(\"styler\", \"suggests\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n:::\n\nThere are only a few functions in `{styler}` that we need to use. The\nfirst is to style a single file by using `styler::style_file()`.\nHowever, an easier function is the \"style active file\" RStudio addin.\nUsually we would only need to style the file that we are actually\nworking on, We can do that through the Command Palette\n({{< var keybind.palette >}}) and typing \"style file\", which should show\nthe \"Style active file\" option. This is what we will do frequently\nthroughout the course.\n\nLet's try it out. While inside the `data-raw/nmr-omics.R` file, use\n{{< var keybind.styler >}} to style the file. There won't be any changes\nsince the file is already tidy.\n\n::: {.callout-note appearance=\"default\"}\nYou will probably be asked to install a package called `{miniUI}`, click\n\"Yes\".\n:::\n\nIf you wanted to run `{styler}` on all the files, we can use:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstyler::style_dir()\n```\n:::\n\n\n\n\nThe thing to note, though, is that `{styler}` isn't perfect, so you\nmight sometimes have to manually fix run the reformatting (with the\nCommand Palette {{< var keybind.palette >}} then \"reformat\").\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nMention the callout block below, but don't go into it at all.\n:::\n\n::: {.callout-tip appearance=\"default\"}\nYou might be used to using 4 spaces for tabs instead of 2. The tidyverse\nstyle uses 2, so the default option in `{styler}`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptions(\n  styler.addins_style_transformer = \"styler::tidyverse_style(indent_by = 4)\"\n)\n```\n:::\n\n\n\n:::\n\n## Styling Markdown files\n\nFor multi-person collaborative projects, having some type of code\nstyling and checker can really help with standardizing how the code\nlooks, which ultimately will make it easier to read each other's code\ncontributions.\n\nBut what about for Markdown files? While there isn't a package or\nfunction (yet) that styles the Markdown files, RStudio does have an\noption in their Tools to format Markdown into a \"canonical form\". The\nreason for this option is because they added a \"visual editor mode\" to\nwriting R Markdown files (which is great if you are more comfortable\nwith apps like Word). Let's test out this option. First, let's make sure\neverything has been committed to the Git history with\n{{< var keybind.git >}}.\n\n::: {.callout-warning appearance=\"default\"}\nUse this option *only if* you have your project under Git version\ncontrol, since it will directly modify and overwrite the contents of the\nentire file.\n:::\n\nThere are two ways of doing this:\n\n1.  Going into\n    [`Tools -> Project Options -> R Markdown`](https://rstudio.github.io/visual-markdown-editing/options.html#project-options)\n    and changing the options \"Automatic text wrapping\" to \"column\" (with\n    the default 72 width value) and \"Write canonical visual mode\n    markdown\" to \"true\".\n2.  Or setting [YAML\n    options](/https://rstudio.github.io/visual-markdown-editing/markdown.html#writer-options)\n    in either the project-level `_quarto.yml` file or at the file-level\n    in the YAML header.\n\nFor right now, we will do the project option settings so that as long as\nwe are using RStudio and in the R Project, it will automatically\nreformat the Markdown files as you write in them. Follow the\ninstructions in item 1 above to set the options.\n\nNow, when you save your file, RStudio should automatically reformat the\nMarkdown into a standardized format. If you want to switch to using the\nVisual Mode, use {{< var keybind.visual-edit >}} or the \"Visual\" button\nat the top of the Source Pane beside the bolding and italicizing\nbuttons.\n\nThe instructors won't be using the Visual Mode during the course,\nhowever you are welcome to. We will be using the \"canonical\" markdown\nmode though.\n\nLet's test it out. While in the `doc/learning.qmd` file, go to the\nbottom of the file and type out:\n\n``` markdown\n## This is poorly formatted\n- Definitely should have an empty space above this list.\n- This isn't a list, why not?\n```\n\nSave the file. What happens? Lists in Markdown need to have an empty\nspace above them to work properly (except for when below a header, but\nin all other cases it needs a space above). With this canonical mode on,\nwe can get feedback right away that it isn't right. It gets\nautomatically fixed by adding that empty space.\n\n``` markdown\n## This is poorly formatted\n\n-   Definitely should have an empty space above this list.\n-   This isn't a list, why not?\n```\n\nSince this mode is on automatically in this project, as we work in the\n`doc/learning.qmd` file through the sessions, we'll get lots of\nexperience using it.\n\n## Exercise: Update the README file, while using canonical markdown mode\n\n> Time: \\~10 minutes.\n\nOpen up the `README.md` file and start completing the `TODO` items. Save\noften and watch as the Markdown gets reformatted. After you are done,\ncommit the changes you made to the Git history with\n{{< var keybind.git >}}. Then delete the `TODO.md`, followed by\ncommitting these deletions in the Git history. Click the \"Push\" button\nto push the changes to GitHub.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\n## Summary\n\n-   Track your project package dependencies with the `DESCRIPTION` file\n    and `{usethis}` and combine it with `options()` to automatically\n    make snapshots so you can use the `use_package()` function.\n-   Install the necessary dependencies with `pak::pak()`.\n-   Follow a style guide by using `{styler}`. Combine with the Command\n    Palette ({{< var keybind.palette >}}) to quickly run their functions\n    on code you are actively working on.\n-   Use RStudio's canonical markdown mode to reformat Markdown into a\n    standard format.\n",
    "supporting": [
      "smoother-collaboration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}