{
  "hash": "3ccbb9af6e79e22e93be4e253864f7ef",
  "result": {
    "markdown": "# Smoother project-based collaboration {#sec-smoother-collaboration}\n\n\n\n\n\nMany of you probably work largely and most consistently on your own, but\nas your move through your career (in academia or industry), you will\nneed to and maybe also want to *directly\ncollaborate*[^smoother-collaboration-1] a lot more with others.\nDifferent types of collaboration (e.g. meetings, brainstorming,\nreal-time co-writing) form the basis for almost all research-based work\nand probably most non-research-based work.\n\n[^smoother-collaboration-1]: Collaborate here meaning directly\n    contributing to a shared project, rather than discussed or planning\n    based collaborations (and definitely not emailing-files-around\n    collaboration).\n\nMore direct collaboration on a project quickly becomes unmanageable when\nusing traditional academic \"workflows\" (emailing around). That's when\nyou need to start using tools designed for collaboration, like Git. But\nGit is just the starting point. There are many many other things to\nconsider for workflows and processes to effectively collaborate with\nothers. This session is about making use of more automated ways of\nstructuring data analysis projects to ease collaboration.\n\n## Learning objectives\n\nThe overall objective for this session is to:\n\n1.  Identify potential actions to streamline collaboration on a data\n    analysis project and create projects that apply many of these\n    actions using R.\n\nMore specific objectives are to:\n\n1.  Explain what a \"project-oriented\" workflow is, what a project-level\n    R dependency management is, what a \"project environment\" is, and why\n    these concepts are important to consider in collaborative and\n    reproducible analyses.\n2.  Describe the difference between \"workflow dependencies\" and \"build\n    dependencies\".\n3.  Apply functions in the `{renv}` and `{usethis}` R packages to\n    implement these dependency management concepts.\n4.  Explain the role that following a style guide has on building a\n    common approach to reading (and writing) R code, and thus improve\n    project-level collaboration.\n5.  Use `{styler}` and RStudio's canonical markdown mode to\n    programmatically check and apply style guides to your project files.\n\n## Exercise: How do you *exactly* collaborate or contribute? To your own or others' projects.\n\n> Time: \\~10 minutes.\n\nWhen you work on a project (for your thesis or a manuscript), how\n**exactly** do you and your collaborators contribute to the project? Is\nit mostly verbal contributions? Do you use a shared folder that the\nfiles are on? How do you keep track of who's changed what? Do you mostly\nwork on your own and contributions are largely verbal or written\nfeedback (like in a meeting or through an email)? If you work directly\non a project, how do you coordinate things? Does one collaborator work\non one section or analysis, so your files are separate? Do you ever have\nto go in and contribute your own code to theirs (and vice versa)?\n\n1.  Take 2 minutes to think on these questions.\n2.  For 6 minutes, discuss these questions with your neighbour, and talk\n    about your own experiences.\n3.  For the remaining time, we will share briefly with everyone.\n\n## Project-level R dependency management\n\n> Note: This first session is more conceptual and is heavier on the\n> reading and explanation, but is important for the next sessions.\n\nOne of the first things to consider when working collaboratively on a\ndata analysis project (and probably other types of projects too) is what\nsoftware to use for your project. This starts out at the highest level:\nAre you using R or some other software for the analysis? Since this is\nan R course, we're assuming the software will be R! ðŸ˜œ\n\nThe next consideration is which packages your project depends on to\nproduce the results. When working collaboratively with others, and\nyourself several months in the future, you need some way of knowing how\nto easily and quickly install or update these package dependencies.\n\nPart of this approach requires that you follow a [\"project-oriented\"\nworkflow](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)\nwhen working on, well, your project. In order to know how to track your\nproject's package dependencies, you need to first know, what is a\n\"project\" and how do we work around it? Since the introduction course's\nfirst session on the [Management of R\nProjects](https://r-cubed-intro.rostools.org/sessions/project-management.html),\nwe've consistently taught and used this workflow-style. In fact, it is\nembedded into the use of the R Projects via the `.Rproj` files and in\nthe use of the `{here}` package. So we already are following this\napproach from the start, which will make it easier to track package\ndependencies of our project.\n\n![Cartoon of combining R Projects with the `{here}` package, compared to\nthe common approach of using `setwd()`. [Artwork by\n\\@allison_horst.](https://allisonhorst.com/allison-horst)](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/e684ee45-98fc-469e-997c-e2d68b0096cd_rw_1920.png?h=d754f634e6fc1e292430124fbe44dad7)\n\nLet's start with the `AdvancedR3` project that uses the `lipidomics`. We\nhave code in the `data-raw/nmr-omics.R` file that uses some packages.\nLet's assume that your project will be more complex than this and that\nyou will eventually need some collaborators to contribute who are\nexperts in for instance metabolomics data processing and in statistical\nanalysis of high-dimensional data. You know you will end up needing to\nuse other packages. You also know that you all need some way of tracking\nwhich packages are used so that when others join and contribute to the\nproject, they can as seamlessly as possible install or update the\npackages your data analysis project needs. There are a few ways of\n\"tracking\" package dependencies.\n\n::: callout-note\n## Reading task: \\~5 minutes\n\n1.  The simplest, but most primitive way is to always make sure to use\n    `library()` at the top of each R script for each package that the R\n    script uses.\n\n    -   Advantage:\n\n        -   This is the easiest to conceptually understand and to use.\n\n    -   Disadvantages:\n\n        -   It doesn't track project-level dependencies very well, since\n            multiple scripts probably use similar packages across them.\n            Which means you can't easily and quickly install or update\n            all the packages your project uses, since you will probably\n            have to go through each R script manually and install each\n            package manually. You might have seen some scripts with code\n            that looks like this at the top:\n\n            ``` r\n            if (!require(\"packagename\")) {\n              install.packages(\"packagename\")\n            }\n            ```\n\n            This code checks if a package exists, if not, it installs\n            it. But! This is not an optimal method to track packages\n            because `require()` won't load the package if it doesn't\n            find it. Which means you would have to re-run the script\n            probably a few times. Plus, sometimes you may need to\n            restart the R session after installing a package in order\n            for R to detect it properly.\n\n        -   It doesn't track the *versions* of the packages your project\n            depends on, so if a package gets updated and it breaks\n            something, you might not be able to figure out how to\n            quickly fix that issue, especially for those deadline\n            crunches.\n\n2.  The most common form, at least based on R packages and projects\n    found on GitHub, makes use of the `DESCRIPTION` file and\n    `usethis::use_package()` to track if a package is used for a project\n    or not. We covered this style of dependency in the [intermediate\n    course](https://r-cubed-intermediate.rostools.org/dry-functions.html#continuing-the-workflow).\n    We will also use this approach during this course, but expand a lot\n    more on it.\n\n    -   Advantages:\n\n        -   Relatively easy to conceptually understand, since you can\n            directly view the packages your project needs by opening the\n            `DESCRIPTION` file and looking at the contents.\n\n        -   Because it is widely used, there are many processes already\n            built around making use of tracking dependencies this way.\n            For instance, you need to track package dependencies when\n            creating R packages.\n\n        -   Installing packages is as easy as opening the project and\n            running `remotes::install_deps()` in the Console, which will\n            install all the packages listed in the `DESCRIPTION` file.\n\n        -   Adding packages that you need is as easy as writing\n            `usethis::use_package(\"packagename\")` in the Console.\n\n    -   Disadvantages:\n\n        -   Like the previous method, it doesn't easily keep track of\n            the versions of the packages you are using.\n\n        -   Your project might still rely on a package that is installed\n            on *your* computer and that influences your project, but\n            that might not be obvious as a dependency or that you forgot\n            to include.\n:::\n\nBefore continuing to the exercise, we need to make sure to add and\ncomment all the files from the project into the Git history. Open the\nGit interface by either typing with {{< var keybind.git >}} or by going\nto the Git pane and clicking the \"Commit\" button.\n\n## Exercise: Add packages from the data processing script\n\n> Time: \\~10 minutes.\n\nSince the `DESCRIPTION` file will be used later on for the more formal\ndependency management, let's get it updated with the packages we are\nusing in the `data-raw/nmr-omics.R` script. Open that file and complete\nthese tasks:\n\n1.  **Manually** look for package dependencies in the R script that are\n    declared with `library()` and `::`. It can help to use the \"Find in\n    files\" feature in RStudio to look for all places that have either\n    `::` or `library`. Use either `Edit -> Find in Files ...`, or with\n    {{< var keybind.find >}} to open up the search popup.\n2.  Use `?usethis::use_package` to review how to use this function.\n3.  In the Console, run `usethis::use_package()` for each package you\n    find in `data-raw/nmr-omics.R` (from 1. above).\n4.  Once done, open the Git interface with {{< var keybind.git >}} (or\n    going to the Git Pane and clicking the \"Commit\" button). What has\n    been changed? Commit those changes to the Git history .\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are really struggling or are out of time for the exercise.\"}\nusethis::use_package(\"stringr\")\nusethis::use_package(\"readxl\")\nusethis::use_package(\"dplyr\")\nusethis::use_package(\"tidyr\")\nusethis::use_package(\"snakecase\")\nusethis::use_package(\"here\")\nusethis::use_package(\"fs\")\nusethis::use_package(\"usethis\")\n```\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nMake sure that everyone has added the right packages, since it can be\neasy to miss some of the packages referenced using `::`.\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## Formal dependency management\n\nWhile the approach of managing package dependencies through the\n`DESCRIPTION` file is quite powerful, it has the major disadvantage of\nnot keeping track of the *version* of each of your packages. So instead\nwe are going to use a package dedicated to handling project\ndependencies, called `{renv}`.\n\n![Cartoon showing a simplified version of what `{renv}` does for R\nProjects, by making them more self-contained. [Artwork by\n\\@allison_horst.](https://allisonhorst.com/allison-horst)](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/3c1eda6b-be13-4257-9c32-4cf865f171ae_rw_1920.png?h=5a6482956a683b2fc417f965674456de)\n\n`{renv}` is a package that manages package dependencies in a project by,\nin simple terms, creating a project-specific R \"library\". You might\nthink of `library()` when you hear R library, and you aren't completely\nwrong. When you call, for instance, `library(\"usethis\")`, R looks for\nthe package `{usethis}` in your computer's \"library\" of R packages. This\nlibrary can be found by running this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/home/luke/Documents/organizations/rostools/r-cubed-advanced/renv/library/R-4.3/x86_64-pc-linux-gnu\"\n[2] \"/home/luke/.cache/R/renv/sandbox/R-4.3/x86_64-pc-linux-gnu/9a444a72\"                                \n```\n:::\n:::\n\n\nThose file paths are where all R packages are installed to. If there is\nmore than one path, R checks the first before continuing to the next.\n`{renv}` instead creates a file path for R packages to be installed\nwithin the project. This isn't completely what it does, since there are\na lot of very technical details to what `{renv}` does internally, but\nthis is the basic concept.\n\nIn the end, this makes your project relatively self-contained in its\npackage dependencies.\n\n-   Advantages:\n\n    -   Installing all packages necessary for your project is as easy as\n        running `renv::restore()`. `{renv}` even gives you helpful tips\n        and instructions when things go wrong or if something is\n        missing.\n\n    -   *Every* package, including the packages that your packages\n        depend on, have their version tracked. So if a package gets\n        updated on CRAN, it doesn't affect you *until you choose*, using\n        `renv::update()`. If a package update breaks your code and you\n        have a deadline, you can easily go back to the older versions of\n        the packages.\n\n    -   Because your project is now self-contained with its own R\n        library, it becomes very obvious (through errors) when you might\n        be missing some other dependency because your code wouldn't run\n        until you install or fix that package dependency.\n\n    -   From a reproducibility point of view, as long as your project is\n        tracked by `{renv}`, it's easier to independently have your data\n        analysis be reproduced and verified.\n\n-   Disadvantages:\n\n    -   It takes a fair amount of learning to conceptually understand\n        what is going on.\n\n    -   When there are issues that come up, it can be difficult to\n        figure them out.\n\n    -   Because *all* packages, including those packages that your\n        packages depend on, are installed within your project,\n        installation times can sometimes be a bit long.\n\n::: aside\nIt's sometimes very annoying to debug these \"virtual environments\". But\nthankfully you can turn it off with `renv::deactivate()`! It still is\nworth it to start considering and accounting for how your dependencies\nmight influence your project results and collaboration.\n:::\n\nLet's start using `{renv}` in our `AdvancedR3` project. In the Console,\ntype out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::init(bare = TRUE)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe function `renv::init()` initializes the project to begin being\nmanaged by `{renv}`. By using the argument `bare = TRUE` we are telling\n`{renv}` to not search for dependencies in the project, since we want to\ndo that ourselves.\n\nWhen initilising a `{renv}` instance using `bare = TRUE` we create a new\n`.libPath()` location that does not contain any of the packages we\npreviously defined as project dependencies. You can notice this if you\nattempt to type `usethis::`, you'll notice that nothing comes up.\nTherefore, before being able to continue our workflow we need to tell\n`{renv}` to install the packages we have already defined as\ndependencies. This can be done with `renv::install()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::install()\n```\n:::\n\n\nAfter doing this we should have several files in our project folder:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n.\nâ”œâ”€â”€ .Rprofile\nâ”œâ”€â”€ renv\nâ”‚   â”œâ”€â”€ .gitignore\nâ”‚   â”œâ”€â”€ activate.R\nâ”‚   â”œâ”€â”€ library\nâ”‚   â”œâ”€â”€ python\nâ”‚   â”œâ”€â”€ sandbox\nâ”‚   â”œâ”€â”€ settings.dcf\nâ”‚   â”œâ”€â”€ settings.json\nâ”‚   â””â”€â”€ staging\nâ””â”€â”€ renv.lock\n```\n:::\n:::\n\n\n-   `.Rprofile`: This is the file that `{renv}` uses to build up its\n    machinery. With an `.Rprofile` within the project folder, we can\n    create a \"project environment\". By having this project environment\n    that is (mostly) self-contained, it allows us to be a bit closer to\n    having a fully reproducible analysis and it makes it easier to\n    collaborate, since we all than share the same project setup.\n\n-   `renv.lock`: (Might not be created yet) This contains all the\n    information about the packages your project depends on, including\n    where it was installed from (CRAN or GitHub for example), what the\n    version number is, and more. This is like a supercharged version of\n    the `DESCRIPTION` file.\n\n-   `renv/`: This folder contains several other files that make up the\n    machinery of `{renv}`. For instance, there is the `library/` folder\n    that contains all the R packages necessary for the project. Then\n    there are the `activate.R` script and `settings.dcf` file that both\n    work to manage the dependencies, like installing, updating, and\n    removing.\n\n\n```{mermaid}\n%%| label: fig-renv-environment\n%%| fig-cap: Simple schematic of how renv is a separate environment.\n%%| echo: false\n%%| eval: true\n%%{init:{'theme':'forest', 'flowchart':{'nodeSpacing': 40, 'rankSpacing': 20}}}%%\ngraph LR\n    user[\"far:fa-folder User/\"] --- root_docs\n    user --- root_desktop\n    user --- .Rprofile\n    subgraph global[Global fab:fa-r-project environment]\n        root_docs[\"far:fa-folder Documents/\"] --- r[\"far:fa-folder R/ (global fab:fa-r-project library)\"]\n        root_desktop[\"far:fa-folder Desktop/\"] --- renv[\"far:fa-folder AdvancedR3/\"]\n        root_docs --- 3[\"far:fa-folder other-projects/\"]\n        .Rprofile\n        subgraph renv_env[Project fab:fa-r-project environment]\n            renv --- renv_folder[\"far:fa-folder renv/<br/>(fab:fa-r-project library)\"]\n            renv --- proj_prof[.Rprofile]\n        end\n    end\n\nlinkStyle 0,1,2,3,4,5,6,7 stroke-width:1px;\n\nclassDef folderEnv fill:transparent,stroke-dasharray:5;\nclass renv_env,global folderEnv\n```\n\n\n**Before we continue, let's commit the new files to the Git history**\nwith {{< var keybind.git >}}.\n\nThe general workflow for using `{renv}` while working on your project is\ndescribed in more detail on the [Introduction to\nrenv](https://rstudio.github.io/renv/articles/renv.html#workflow)\nwebpage. However, unlike the general workflow, we also want to continue\nusing the `DESCRIPTION` file. That's because a lot of tools and\nworkflows exist that make use of it, so we want to remain compatible\nwith them.\n\nAs we work on the project and realize we need to use a specific package,\nwe would normally use `install.packages()` and then add `library()` to\nthe script or R Markdown file. Later on, we'd eventually run\n`renv::snapshot()` to update the `renv.lock` file with the new packages\nwe've installed. `renv::snapshot()` as well as `renv::init()` usually\nrely on \"implicit\" dependencies, meaning `{renv}` will search throughout\nthe project for any packages used and add them to the `renv.lock` file.\n\nHowever, in science, we want to be more explicit rather than implicit.\nThe way `{renv}` explicitly adds to the `renv.lock` file is by only\nscanning the `DESCRIPTION` file. In order for `{renv}` to always do\nthis, we need to set an option for it. This option needs to be added to\nthe project's `.Rprofile` file.\n\nWe also want to use the `{pak}` package to install R packages instead of\n`install.packages()` because it is much more powerful and faster. We can\ntell `{renv}` to use `{pak}` instead by adding an option, which we will\nbe doing anyway.\n\nWe can quickly open this with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_profile(\"project\")\n```\n:::\n\n\nNext, at the top of the file, add this code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\n  renv.settings.snapshot.type = \"explicit\",\n  renv.config.auto.snapshot = TRUE,\n  renv.config.pak.enabled = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThese three options make it so that whenever you add a package with\n`usethis::use_package()` or `pak::pak()`, `{renv}` will always run\n`renv::snapshot()` and the snapshot explicitly only look at the\n`DESCRIPTION` file. Let's restart the R session so that the `.Rprofile`\nchanges get activated.\n\nNow our `{renv}` workflow will largely be automated for us, as long as\nwe do `usethis::use_package()`. If we ever ever return to a project or\ncollaborate on a project that uses `{renv}`, we can install all the\nnecessary packages with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::restore()\n```\n:::\n\n\nAnd if we need to update packages, we use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::update()\n```\n:::\n\n\n*Sometimes*, working with `{renv}` can get annoying and you just need to\nfinish working on a task. If that's the case, you can always do\n`renv::deactivate()` to stop using `{renv}` and `renv::activate()` to\nreactivate it.\n\n**Let's commit the changes made to the Git history** with\n{{< var keybind.git >}}.\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nIt's surprising how many issues can come up, from a reproducibility\nperspective, when it comes to managing package dependencies. You think\nsomething works well on your computer, but when you create a \"virtual\nenvironment\" like you do when using `{renv}`, you realize it might not\nwork as well on other computers.\n\nWhen this happens, there are several functions you can use to help debug\nthe situation.\n\n`renv::diagnostics()`\n\n:   List a *lot* of diagnostic information to look over. Sometimes its\n    too much, but can help figure out what's going on.\n\n`renv::clean()`\n\n:   Installing packages can sometimes lead to issues in the files of the\n    installed packages themselves or even left over temporary files.\n    This function tries to clean up these issues for you. It can also\n    clean up any unused packages\n\n`renv::repair()`\n\n:   Because of the way `{renv}` works, the connection to where an\n    installed package is actually found can get broken. So this function\n    tries to fix that and reinstall these broken packages.\n\n`renv::rebuild()`\n\n:   The last resort, use this to reinstall everything from scratch.\n:::\n\n## Two types of dependencies\n\nWhen you work on a research project that involves data analysis, you\nlikely use packages in two different ways:\n\n1.  Packages that directly contribute to data wrangling, analysis,\n    plotting, and making the manuscript. These types of packages are\n    generally called \"build\" or \"deploy\" dependencies. A package like\n    `{dplyr}` or `{tidyr}` would be build dependencies, since you use\n    them for processing data.\n2.  Packages that assist you in doing your work but aren't directly used\n    for data analysis. These types of packages would be called\n    \"workflow\" or \"development\" dependencies. `{renv}` would be\n    considered a workflow dependency.\n\nA good way to determine if a package is a *build dependency* for your\nproject is by seeing if you write and use functions from the package\nwithin an R script that does something to the data or analysis. If you\n*only* ever use functions from the package in the Console, than it is\nlikely a *workflow dependency*.\n\nThe way you add these packages is different depending on the type it is.\nFor build dependencies, we use the function we've already used before:\n`usethis::use_package(\"packagename\")`. For workflow dependencies, it's\nthe same function, but with a small difference. BUT! Before we cover it,\nlet's add a setting to our `.Rprofile` to make our life a bit easier. We\nwill be using `{usethis}` functions many times throughout the course, so\na simple quality-of-life fix is to make it so we don't always have to do\n`usethis::`. Thankfully, there is a function that can help. Create and\nopen the project `.Rprofile` with `usethis::edit_r_profile()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_profile(\"project\")\n```\n:::\n\n\nThen copy and paste this code into the `.Rprofile`:\n\n``` r\nif (interactive()) {\n  suppressMessages(require(usethis))\n}\n```\n\n\n::: {.cell}\n\n:::\n\n\nLet's restart R with {{< var keybind.restart-r >}} before using\n`use_package()` to add `{renv}` as a workflow dependency.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"renv\", \"suggests\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nOpen the Git interface and see that under `Suggests:` in the\n`DESCRIPTION` file is `renv`. Let's commit these changes, as well as the\nchanges to `.Rprofile`, with {{< var keybind.git >}}.\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nFor the information block below, mention it to the learners but you\ndon't need to go over it. Especially mention the second part of the tip.\n:::\n\n::: {.callout-tip appearance=\"default\"}\nWhen you come back to a project after a few months or if you start\ncollaborating on a project, usually `renv::restore()` will be enough to\ninstall all types of dependencies. Sometimes though, workflow\ndependencies might not get installed. As long as they are tracked in the\n`DESCRIPTION` file though, you can force installation of them with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::install()\n```\n:::\n\n\nDepending on your operating system (Windows, MacOS, or Linux), using\n`use_package()` might actually install the package again, even though\nyou already have it. In that case, you can use\n`renv::install(\"packagename\")` first, before than using `use_package()`.\n:::\n\n## Exercise: Connect your project to GitHub\n\n> Time: \\~25 minutes.\n\nSince we will eventually connect our project Git repository to GitHub to\ndisplay a website as well as to practice the workflow, we'll connect our\nproject to GitHub right now.\n\nLet's complete these tasks to connect to GitHub.\n\n1.  First, commit the latest changes to the Git history with\n    {{< var keybind.git >}}.\n\n2.  If you haven't yet, please create a\n    [GitHub](https://github.com/join) account.\n\n3.  Add the `{gitcreds}` package as a workflow dependency. You'll need\n    it for the next item\n\n    ``` r\n    use_package(\"gitcreds\", \"suggests\")\n    ```\n\n4.  Read through and complete the tasks in the [Connect to GitHub\n    Guide](https://guides.rostools.org/connect-github).\n\n5.  Check your GitHub to make sure the project repository has been\n    uploaded to it.\n\n## Automatically adhere to a style guide\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nWe've covered how to adhere to a style guide in both the introductory as\nwell as the intermediate course, because it is such a useful and\npowerful tool to easily write more readable code. We'll expand on it in\nthis course because it fits precisely with the theme of collaboration.\nThat's because, when you're working on your own and not needing to worry\nabout anyone seeing your code, there's a natural temptation to write\nyour code like you might write notes to yourself... scribbled and\nscrawled down quickly. But when working with others, how it looks can\ngreatly impact how quickly and easily others are able to read and\ninterpret your code. Multiply all the collaborators on a project with\nthis natural temptation for quick (and sloppy) coding, you can imagine\nhow easy it is for code to massively \"drift\" towards being poorly\nformatted, especially when deadlines are close.\n\nThat's when \"linters\" or \"stylers\" (types of \"static code analysis\"\ntools) become very useful. They will scan your code for common mistakes\nor syntax problems and either list them out for you to fix or fix them\nfor you automatically. Linters are great when you are collaborating on a\nproject with collaborators who are not as experienced in writing code or\nwho only occasionally contribute so don't know the workflow culture of\nyour project. In this way, you might want to have automatic\nlinting/styling checks that are independent of you having to run them\nyourself. This is where the `{styler}` package comes in!\n\nSince we will use it for the project as a workflow dependency, let's add\nit to the `DESCRIPTION` file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"styler\", \"suggests\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n:::\n\nThere are only a few functions in `{styler}` that we need to use. The\nfirst is to style a single file by using `styler::style_file()`.\nHowever, an easier function is the \"style active file\" RStudio addin.\nUsually we would only need to style the file that we are actually\nworking on, We can do that through the Command Palette\n({{< var keybind.palette >}}) and typing \"style file\", which should show\nthe \"Style active file\" option. This is what we will do frequently\nthroughout the course.\n\nLet's try it out. While inside the `data-raw/nmr-omics.R` file, use\n{{< var keybind.styler >}} to style the file. There won't be any changes\nsince the file is already tidy.\n\n::: {.callout-note appearance=\"default\"}\nYou will probably be asked to install something, click \"Yes\".\n:::\n\nIf you wanted to run `{styler}` on all the files, we can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyler::style_dir()\n```\n:::\n\n\nThe thing to note, though, is that `{styler}` isn't perfect, so you\nmight sometimes have to manually fix run the reformatting (with the\nCommand Palette {{< var keybind.palette >}} then \"reformat\").\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nMention the callout block below, but don't go into it at all.\n:::\n\n::: {.callout-tip appearance=\"default\"}\nYou might be used to using 4 spaces for tabs instead of 2. The tidyverse\nstyle uses 2, so the default option in `{styler}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\n  styler.addins_style_transformer = \"styler::tidyverse_style(indent_by = 4)\"\n)\n```\n:::\n\n:::\n\n## Styling Markdown files\n\nFor multi-person collaborative projects, having some type of code\nstyling and checker can really help with standardizing how the code\nlooks, which ultimately will make it easier to read each other's code\ncontributions.\n\nBut what about for Markdown files? While there isn't a package or\nfunction (yet) that styles the Markdown files, RStudio does have an\noption in their Tools to format Markdown into a \"canonical form\". The\nreason for this option is because they added a \"visual editor mode\" to\nwriting R Markdown files (which is great if you are more comfortable\nwith apps like Word). Let's test out this option. First, let's make sure\neverything has been committed to the Git history with\n{{< var keybind.git >}}.\n\n::: {.callout-warning appearance=\"default\"}\nUse this option *only if* you have your project under Git version\ncontrol, since it will directly modify and overwrite the contents of the\nentire file.\n:::\n\nThere are two ways of doing this:\n\n1.  Going into\n    [`Tools -> Project Options -> R Markdown`](https://rstudio.github.io/visual-markdown-editing/options.html#project-options)\n    and changing the options \"Automatic text wrapping\" to \"column\" (with\n    the default 72 width value) and \"Write canonical visual mode\n    markdown\" to \"true\".\n2.  Or setting [YAML\n    options](/https://rstudio.github.io/visual-markdown-editing/markdown.html#writer-options)\n    in either the project-level `_quarto.yml` file (we will cover this\n    in @sec-build-website) or at the file-level in the YAML header.\n\nFor right now, we will do the file-level YAML settings. Open the\n`doc/learning.qmd` file and go to the top of the file. Right below the\nlast `---`, create a new line above it and paste this code in:\n\n``` yaml\neditor_options:\n  markdown:\n    wrap: 72\n    canonical: true\n```\n\n\n::: {.cell}\n\n:::\n\n\nNow, when you save your file, RStudio should automatically reformat the\nMarkdown into a standardized format. If you want to switch to using the\nVisual Mode, use {{< var keybind.visual_edit >}} or the \"Visual\" button\nat the top of the Source Pane beside the bolding and italicizing\nbuttons.\n\nThe instructors won't be using the Visual Mode during the course,\nhowever you are welcome to. We will be using the \"canonical\" markdown\nmode though.\n\nLet's test it out. While in the `doc/learning.qmd` file, go to the\nbottom of the file and type out:\n\n``` markdown\n## This is poorly formatted\n- Definitely should have an empty space above this list.\n- This isn't a list, why not?\n```\n\nSave the file. What happens? Lists in Markdown need to have an empty\nspace above them to work properly (except for when below a header, but\nin all other cases it needs a space above). With this canonical mode on,\nwe can get feedback right away that it isn't right. It gets\nautomatically fixed by adding that empty space.\n\n``` markdown\n## This is poorly formatted\n\n-  Definitely should have an empty space above this list.\n-  This isn't a list, why not?\n```\n\nSince this mode is on automatically in the `doc/learning.qmd` file, as\nwe work through the sessions, we'll get lots of experience using it.\nWe'll also eventually switch so that the whole project uses this mode.\n\n## Exercise: A few small changes to improve your workflow\n\n> Time: \\~2 minutes.\n\nThere are many options inside the Global Options in RStudio that can\nhelp you work better and faster. There are a few that will help a lot,\nespecially in this course and with the workflows we are showing:\n\n-   Go into `Tools -> Global Options -> Code -> Saving`.\n    -   Under the heading \"General\", tick on all of those check boxes.\n    -   Under the heading \"Auto-save\", tick on both those check boxes.\n\n## Exercise: Update the README file, while using canonical markdown mode\n\n> Time: \\~10 minutes.\n\nOpen up the `README.md` file and copy and paste these YAML metadata to\nthe top:\n\n``` markdown\n---\neditor_options:\n  markdown:\n    wrap: 72\n    canonical: true\n---\n```\n\nThen, start completing the `TODO` items. Save often and watch as the\nMarkdown gets reformatted. After you are done, commit the changes you\nmade to the Git history with {{< var keybind.git >}}. Then delete both\n`TODO.md`, followed by committing these deletions in the Git history.\nClick the \"Push\" button to push the changes to GitHub.\n\n\n::: {.cell}\n\n:::\n\n\n## Add r3 in order to complete the survey\n\nWe're at the end of the session and now need to fill in the survey.\nThere is a function in r3, but r3 isn't installed in our project\nlibrary. However, because r3 has a few GitHub packages as dependencies,\nwe need to tell `{renv}` to authenticate us to GitHub so we can install\nas much as we want (GitHub only allows a few unauthenticated installed,\nas a security feature against hackers and cyber attacks). Using\n`gitcreds::gitcreds_set()` with the GitHub token we created should be\nenough for `{renv}` to know what to do. If you encounter an error about\na GitHub API limit, run this code again so you can authenticate yourself\nwith your token.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngitcreds::gitcreds_set()\n```\n:::\n\n\nThen we can install the r3 package into our project with\n`renv::install()`. Because the r3 package is on GitHub, we need to tell\n`{renv}` about its location by adding `github::` followed by the \"user\"\n(which is `rostools`) and than the repository (`r3`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::install(\"github::rostools/r3\")\n```\n:::\n\n\nNow we can open the feedback survey:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr3::open_feedback_survey_advanced()\n```\n:::\n\n\n## Summary\n\n-   Track your project package dependencies with `{renv}` and combine it\n    with `options()` to automatically make snapshots so you can use the\n    `use_package()` function.\n-   Install the necessary dependencies with `renv::restore()` or\n    `renv::install()`.\n-   Follow a style guide by using `{styler}`. Combine with the Command\n    Palette ({{< var keybind.palette >}}) to quickly run their functions\n    on code you are actively working on.\n-   Use RStudio's canonical markdown mode to reformat Markdown into a\n    standard format.\n",
    "supporting": [
      "smoother-collaboration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}