# A general approach to doing statistical analyses {#sec-stats-analyses-basic}

```{r setup}
#| include: false
source(here::here("R/functions.R"))
extract_functions_from_qmd()
source(here::here("R/project-functions.R"))
library(tidyverse)
library(tidymodels)
lipidomics <- read_csv(here::here("data/lipidomics.csv"))
```

When working with data in research it is almost impossible to avoid
needing to do some form of statistical analysis. Running statistical
analyses is usually methodical and well-defined, though it often
involves trial and error. As it involves several steps: choosing the
right analysis to do for your data, ensuring that your data is
transformed in the right way to do your chosen statistical analysis, and
lastly, extracting the results of your statistical analysis so you can
present them. Sometimes it may feel overwhelming and complicated, which
it definitely can be, but it doesn't have to be. By taking a structured
approach, you can make the process easier and feel more in control.

In R, statistical methods are often developed by researchers with little
software training, which can make learning new methods challenging.
However, having a framework for running analyses can simplify the
process.

For this session, we are going to learn how we can generally set up and
run statistical models, so that we can use it within `{targets}`.



## Learning objectives

{{< include /includes/objectives/_stats-analyses-basic.qmd >}}

Specific "anti"-objectives on things that we will *not* learn:

-   How to choose and apply the appropriate statistical model or tests.
-   Statistical theory.
-   How to determine relevant data transformations for statistical
    tests.
-   How to interpret the statistical results.

This means that what we show is *for demonstration purposes only*. Our
implementation and choice of model and analyses could be wrong if an
expert were to review them.

::: {.callout-warning appearance="default"}
We will be making *a lot* of function throughout this session and the
next. This is just a fair warning!
:::

## Taking a step back and thinking about the design

With functional programming, it's best to design code in a way that
breaks down the process into smaller pieces. Each piece should take a single
input and return a single output, so that we can eventually chain them together
into a single pipeline. When we've made a pipeline that can output results for
one thing, it's fairly easy to extend that to do multiple things at once too.

So this session is about running a basic statistical analysis for one
single research question, as a statistical model. The next session will be
taking what we've done here and applying it to run many at once.

```{mermaid}
flowchart TB
    q[Question] -->|?| result[Result]
```

```{mermaid}
flowchart TB
    q[Question] -->|?| model[Model]
    model -->|?| result[Result]
```


## :speech_balloon: Discussion activity: What does a "model" mean?

**Time: ~6 minutes.**

In science and especially statistics, we talk a lot about "models". But
what does model actually mean? What different types of definitions can
you think of? Is there a different understanding of model in statistics
compared to other areas?

1.  Take 1 minute to think about your understanding of a model.
2.  Then, over the next 3 minutes, discuss with your neighbour about the
    meaning of "model" and see if you can come to a shared
    understanding.
3.  Finally, over the next 2 minutes, we will share all together what a
    model is in the context of data analysis.

## :book: Reading task: A brief introduction to statistical modelling and workflow

**Time: ~15 minutes.**

::: {.callout-note collapse="true"}
## :teacher: Instructor note

Let them read it over than go over it briefly, focusing on what a model
is, that we should create research questions while thinking in the
framework of models, and the general workflow for doing statistical
analyses.
:::

<!-- TODO: Create a revealjs presentation on this? -->

Research, especially quantitative research, is about making inferences
about the world by quantifying uncertainty from some data. And we
quantify uncertainty by using statistics and statistical models.

A statistical model is a simple way to describe the real world using
mathematics. In research, we often aim to understand the relationships
between multiple variables. For example, if we change the predictor
(independent variable or $x$), how does that affect the outcome
(dependent variable or $y$)?

Some simple examples are:

-   "How does this new cancer treatment affect survival rates?"
-   "How does this new user interface affect user watch time?"

or more complex:

-   "How does sunlight and water affect plant growth?"
-   "What is the relationship between a metabolite and type 1 diabetes
    compared to controls, adjusting for age and gender?"

These relationships can involve single or multiple predictors (such as
sunlight and water, or metabolite, gender, and age). The outcomes can be
either continuous (such as plant growth) or categorical (such as whether
a person has type 1 diabetes or not).

The relationship between predictors and the outcome is known as a
regression. If there is a relationship between ($x$) and ($y$), the
corresponding mathematical object is a function, $f()$:

$$y = f(x)$$

Since no relationship is perfect, we add some random error (error) to
describe the difference between the function and the actual measured
variables:

$$y = f(x) + error$$

The simplest form of regression is linear regression, where the formula
is a linear combination:

$$y = intercept + x + error$$

Here, the $intercept$ is the value of $y$ when $x$ is zero.

For example, we might expect a relationship between plant growth, water,
and sunlight. We could model plant growth as depending on water and
sunlight. Graphically, we can illustrate this model as:

```{mermaid fig-model-plant-growth}
%%| fig-cap: Simple example of a theoretical model of plant growth.
%%| echo: false
%%| eval: true
graph LR
    Sunlight --> Growth
    Water --> Growth
    Sunlight --- Water
```

or mathematically:

$$growth = sunlight + water$$

This expression is known as our theoretical model. However, not all
theoretical models can be tested against the real world. We need to
structure the theoretical model so that we can measure the parameters---
the variables like growth, sunlight, and water in the model above---
involved. In this case, we need to measure plant growth (e.g., weight in
grams), the amount of water given per day (in liters), and the number of
sunlight hours per day.

This also means that when formulating a research question, there is an
order to follow:

1.  **Write a research question** that fits a theoretical model with
    measurable parameters.

2.  **Select the best model type** based on the model parameters (e.g., linear
    regression, logistic regression, ANOVA, or t-test).

3.  **Measure your parameters** (e.g., water in liters per day, plant
    growth in weight, sunlight in hours per day).

4.  **Fit the data to the model** to estimate the values (coefficients)
    of the model, such as the intercept, slope, and uncertainty (error).

5.  **Extract and present the values** in relation to your research
    questions.

```{mermaid fig-model-building-workflow}
%%| fig-cap: Simple schematic of the workflow for conducting statistical analysis.
%%| echo: false
%%| eval: true
graph TD
    A[Research question] --> B((Statistical model))
    B --> A
    B --> C[Data collection]
    C --> D[Data transformation]
    D --> E[Scientific output]
    E --> A
```

::: {.callout-caution appearance="default"}
The entire workflow for building statistical models requires highly
specific domain knowledge on not only the statistics themselves, but
also how the data was collected, what the values mean, what type of
research questions to ask and how to ask them, how to interpret the
results from the models, and how to process the data to fit the question
and model.

For instance, in our `lipidomics` dataset, if we were to actually use
this data, we would need someone familiar with -omic technologies, how
the data are measured, what the values actually mean, how to prepare
them for the modeling, the specific modeling methods used for this
field, and how we would actually interpret the findings. We have
**none** of these things, so very likely we are doing things quite wrong
here. We're only doing this modeling to highlight how to use the R
packages.
:::

```{mermaid}
```{mermaid}
flowchart TB
    q[Question] -->|?| model[Model]
    model & data[Data] -->|?| result[Result]
```
```

Furthermore, because we are working within a "reproducible analysis"
framework specifically with the use of `{targets}`, we will also convert
questions regarding our lipidomics data into outputs to include as
pipeline targets, along with a basic idea for the final functions that
will make up these targets and their inputs and outputs. These targets
will probably be quite different by the end, but it's a good start to
think about what it should look like in the end.

-   All results for estimated relationships (in case we want to use it
    for other output)
-   Plot of statistical estimate for each relationship

Potential function names might be:

-   `calculate_estimates()`
-   `plot_estimates()`

```{mermaid fig-model-possible-targets}
%%| fig-cap: Potential inputs, outputs, and functions for the targets pipeline.
%%| echo: false
%%| eval: true
graph TB
    lipidomics -- "calculate_estimates()" --> model_est[Model estimates]
    model_est -- "plot_estimates()" --> plot_est[Plot of estimates]
    plot_est -- "tar_read()" --> qmd[Quarto]
```

{{< text_snippet sticky_up >}}

::: {.callout-note collapse="true"}
## :teacher: Instructor note

A few things to repeat and reinforce:

1.  The workflow of the image and that it all starts with the research
    question.
2.  The fact that almost all statistical methods are basically special
    forms of linear regression.
3.  That this model creation stage requires a variety of domain
    expertise, not just statistical expertise.

Also repeat the question to ask, the outputs, as well as the functions
and their flow that we can translate into the `{targets}` pipeline.
:::

## :book: Reading task: Defining a model for our lipidomics data

**Time: ~10 minutes.**

::: {.callout-note collapse="true"}
## :teacher: Instructor note

Let them read it first and then briefly verbally walk through this
section, describing the theoretical model both graphically and
mathematically. Go through why we use `{tidymodels}` rather than other
approaches.
:::

Going back to our own lipidomics dataset, we need to do the first step:
Creating the question. While we don't have much data, there are a
surprising number of questions we could ask. But we will keep it very
simple, very basic, and very exploratory.

1.  What is the estimated relationship of each metabolite with type 1 diabetes
    (T1D) compared to the controls, adjusting for the influence of age and gender?

A graphical representation of this theoretical model could be:

```{mermaid fig-model-research-question}
%%| fig-cap: A simple theoretical model of the research question about T1D status.
%%| echo: false
%%| eval: true
graph TB
    Metabolite --> T1D
    Age & Gender --> T1D & Metabolite
```

Or mathematically:

$$T1D = metabolite + age + gender$$

So, T1D status (or `class` in the `lipidomics` dataset) is our
**outcome** and the individual metabolite, age, and gender are our
**predictors**. Technically, age and gender would be "confounders" or
"covariates", since we include them only because we think they influence
the relationship between the metabolite and T1D.

If we convert the formula into a form with the variables we have in the
dataset as well as selecting only one metabolite for now (the
cholesterol metabolite, which we add "metabolite" to differentiate it
from other potential variables), it would be:

$$class = metabolite\_cholesterol + age + gender$$

Now that we have a theoretical model, we need to choose our model type.
Since T1D is binary (either you have it or you don't), the most likely
choice is logistic regression, which requires a binary outcome variable.
So we have the theoretical model and the type of model to use, now how
do we express this as code in R? There are many ways of doing the same
thing in R, but some are a bit easier than others.

## Creating the list of model formulas

```{mermaid}
flowchart TB
    qs[Questions] --> models[Models]
    models & data[Data] -->|?| rs[Results]
```

Let's switch to working in the `doc/learning.qmd` file to create those
logistic regression models. In the `doc/learning.qmd` file, on the
bottom of the document create a new header and code chunk:

```` {.markdown filename="docs/learning.qmd"}
## Building the model

```{{r}}

```
````

In the new code chunk, we will set up the model formula:


Running this on it's own doesn't show much, as you can see. But we've
now set the model we want to use.

## Data transformations specific to modeling

Setting the model type was pretty easy right? The more difficult part
comes next with the data transformations. `{recipes}` functions are
almost entirely used to apply transformations that a model might
specifically need, like mean-centering, removing missing values, and
other aspects of data processing.

Let's consider our `lipidomics` dataset. In order for us to start our
statistical analysis, we need the data to be structured in a certain way
to be able to smoothly use it as input in our model. We have at least
three necessary transformations, two of which can be done using a single
`{tidyr}` function, while the third one can be fixed with `{recipes}`.
Can you spot them?

```{r}
#| filename: Console
lipidomics
```

::: {.callout-note collapse="true"}
## :teacher: Instructor note

Ask them if they can spot the structural data issues. Give them a few
minutes to think and respond.
:::

The first issue, which isn't always an issue, depends heavily on the
model type you use. Since we are using logistic regression, the model
assumes that each row is an individual person. But our data is in the
long format, so each person has multiple rows. The second issue is that
there seems to be a data entry error, since there are multiple
`Cholesterol` values, while all other metabolites only have one:

```{r too-many-cholesterols}
#| filename: "docs/learning.qmd"
lipidomics |>
  count(code, metabolite) |>
  filter(n > 1)
```

We can fix both the long format and multiple cholesterol issues by using
`tidyr::pivot_wider()`. Before we do, the last issue is that each
metabolite has quite large differences in the values and ranges of data.
Again, whether this is an issue depends on what we want to do, but in
our research question we want to know how each metabolite influences
T1D. In order to best interpret the results and compare across
metabolites, we should ideally have all the metabolites with a similar
range and distribution of values.

Let's fix the first two issues first, and at the same time tidy up the
names of each metabolite so they make better column names. In the
`docs/learning.qmd`, we can tidy up the metabolite names using `mutate()`
with `snakecase::to_snake_case()`. Secondly, to make our dataset wider,
we use `pivot_wider()`. Since we also want an easy way of identifying
columns that are metabolites, we will add a `"metabolite_"` prefix using
the argument `names_prefix`. To actually fix the multiple cholesterol
issue, we should look more into the data documentation or contact the
authors. But for this workshop, we will merge the values by calculating a
mean before pivoting. We do this by setting the `values_fn` with `mean`.

```{r lipidomic-to-wider}
#| filename: "docs/learning.qmd"
lipidomics_wide <- lipidomics |>
  mutate(predictor = snakecase::to_snake_case(metabolite)) |>
  pivot_wider(
    names_from = predictor,
    values_from = value,
    values_fn = mean,
    names_prefix = "metabolite_"
  )
lipidomics_wide
```

This on its own should work. *However*, the column we want to change
might not always be called `metabolite`, or we might want to change it
later. So, to make this function a bit more generic, we can use
something called "curly-curly" (it looks like `{{}}` when used) and
"non-standard evaluation" (NSE).

## :book: Reading task: Non-standard evaluation and curly-curly

**Time: ~10 minutes.**

When you write your own functions that make use of functions in the
`{tidyverse}`, you may eventually encounter an error that might not be
very easy to figure out. Here's a very simple example using `select()`,
where one of your function's arguments is to select columns (just read,
don't write any code):

```{r, error=TRUE}
test_nse <- function(data, columns) {
  data |>
    dplyr::select(columns)
}

lipidomics |>
  test_nse(class)
```

The error occurs because of something called "[non-standard
evaluation](http://adv-r.had.co.nz/Computing-on-the-language.html)" (or
NSE). NSE is a major feature of R and is used quite a lot throughout R.
NSE is used a lot in the `{tidyverse}` packages. It's one of the first
things computer scientists complain about when they use R, because it is
not a common thing in other programming languages. But NSE is what
allows you to use formulas (e.g. `y ~ x + x2` in modeling, which we will
show shortly) or allows you to type out `select(class, age)` or
`library(purrr)`. In "standard evaluation", these would instead be
`select("Gender", "BMI")` or `library("purrr")`. So NSE gives
flexibility and ease of use for the user (we don't have to type quotes
every time) when doing data analysis, but can give some headaches when
programming in R, like when making functions. There's more detail about
this on the [dplyr
website](https://dplyr.tidyverse.org/articles/programming.html#warm-up),
which lists some options to handle NSE while programming. The easiest
approach is to wrap the argument with "curly-curly" (`{{}}`).

```{r}
test_nse <- function(data, columns) {
  data |>
    dplyr::select({{ columns }})
}

lipidomics |>
  test_nse(class)

lipidomics |>
  test_nse(c(class, age))
```

{{< text_snippet sticky_up >}}

## Using curly-curly when using tidyverse functions in our own functions

::: {.callout-note collapse="true"}
## :teacher: Instructor note

You don't need to go over what they read, you can continue with making
the function below. Unless learners have some questions.
:::

## Pre-processing before modeling

::: {.callout-note collapse="true"}
## :teacher: Instructor note

Verbally talk through the next few paragraphs, no code-along yet.
:::

We've used `{dplyr}` and `{tidyr}` to start fixing some of the issues
with the data. But we still have the third issue: How to make the
results between metabolites comparable.

There are many transformations we could use for the `lipidomics`
dataset, but we will use normalization for this workshop. This
function is useful because it makes each variable centered to zero and a
value of 1 unit is translated to 1 standard deviation of the original
distribution. This means we can more easily compare values between
variables.


Style using {{< var keybind.styler >}}, then commit the changes made to
the Git history with {{< var keybind.git >}}.

## Fitting the model to the data {#sec-fitting-model}

We've now defined the model we want to use and transformed the data.
Now we can start putting them together and
finally fit them to the data.

To get this information in a tidier format, we use another function:
`tidy()`. This function comes from the `{broom}` package, which is part
of the `{tidymodels}`. But we should explicitly add it to the
dependencies:

```{r broom-to-deps}
#| purl: true
#| eval: false
#| filename: Console
use_package("broom")
```

Then, we add the `tidy()` function to our model using the `|>` pipe.
Since we are using a logistic regression model, we need to consider how
we want the estimates to be presented, probably depending on how we want
to visualize our results. If we set `exponentiate = TRUE` in `tidy()`,
the output estimates will be odds ratios, if we set
`exponentiate = FALSE`, we will get the log odds ratios. Here we choose
`exponentiate = TRUE`:

```{r tidy-up-model-results}
#| filename: "docs/learning.qmd"
fitted_model |>
  tidy(exponentiate = TRUE)
```

We now have a data frame of our model results!

::: {.callout-note collapse="true"}
## :teacher: Instructor note

Reinforce **not** to worry about interpreting the results, that is not
the aim of this workshop.
:::

::: callout-important
Another reminder, we **are not** interpreting this results. For this
workshop, they are **not** important and can distract from the main
purpose.
:::

Let's briefly cover what these columns and values mean.
But first, open the Git interface and commit the changes you made
with {{< var keybind.git >}}. Then push your changes up to GitHub.

::: {.callout-note collapse="true"}
## :teacher: Instructor note

If you want, you can go over these details briefly or in more detail,
depending on how comfortable you are. Or you can get them to read it
only.
:::

## :book: Reading task: Understanding the model output

**Time: ~10 minutes.**

Let's explain this output a bit, each column at a time:

-   `term`: If you recall the formula
    $class = metabolite + sex + gender$, you'll see all but the `class`
    object there in the column `term`. This column contains all the
    predictor variables, including the intercept (from the original
    model).

-   `estimate`: This column is the "coefficient" linked to the term in
    the model. The final mathematical model here looks like:

    $$ \displaylines{class = Intercept + (metabolite\_estimate \times metabolite\_value) + \\ (gender\_estimate \times gender\_value) + ...}$$

    In our example, we chose to get the odds ratios. In the mathematical
    model above, the estimate is represented as the log odds ratio or
    beta coefficient - the constant value you multiply the value of the
    term with. Interpreting each of these values can be quite tricky and
    can take a surprising amount of time to conceptually break down, so
    we won't do that here, since this isn't a statistics workshop. The
    only thing you need to understand here is that the `estimate` is the
    value that tells us the *magnitude* of association between the term
    and `class`. This value, along with the `std.error` are the most
    important values we can get from the model and we will be using them
    when presenting the results.

-   `std.error`: This is the uncertainty in the `estimate` value. A
    higher value means there is less certainty in the value of the
    `estimate`.

-   `statistic`: This value is used to, essentially, calculate the
    `p.value`.

-   `p.value`: This is the infamous value we researchers go crazy for
    and think nothing else of. While there is a lot of attention to this
    single value, we tend to give it more attention than warranted. The
    interpretation of the p-value is even more difficult than the
    `estimate` and again, we won't cover this in this workshop. We won't
    be using this value at all in presenting the results.

{{< text_snippet sticky_up >}}

## Summary

-   Create research questions that (ideally) are structured in a way to
    mimic how the statistical analysis will be done, preferably in a
    "formula" style like $y = x1 + x2 + ... + error$ and in a diagram
    style with links connecting variables.
-   Statistical analyses, while requiring some trial and error, are
    surprisingly structured in the workflow and steps taken. Use this
    structure to help guide you in completing tasks related to running
    analyses.
-   Use `{broom}` to `tidy()` the model output, extracted using
    `extract_fit_parsnip()` to get a data frame of the estimates and
    standard error for the variables in the model.

{{< include /includes/_code-appendix.qmd >}}
